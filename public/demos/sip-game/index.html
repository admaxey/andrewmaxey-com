<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>Super Identity Partners v0.67</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;background:#0a0a1a;overflow:hidden;touch-action:none;-webkit-user-select:none;user-select:none;font-family:monospace}
#container{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;gap:10px}
#screen{background:#1a1a2e;border-radius:12px;padding:10px;box-shadow:0 4px 24px rgba(0,0,0,0.5)}
#game{display:block;image-rendering:pixelated;image-rendering:crisp-edges;border-radius:4px;background:#000}
#controls{display:flex;justify-content:space-between;width:100%;max-width:420px;padding:0 12px}
.dpad{width:100px;height:100px;position:relative}
.dpad-btn{position:absolute;width:32px;height:32px;background:linear-gradient(145deg,#3a3a5a,#2a2a3a);border:2px solid #4a4a6a;border-radius:6px;color:#888;font-size:14px;display:flex;align-items:center;justify-content:center}
.dpad-btn:active{background:#5a5a8a;transform:scale(0.95)}
.dpad-up{top:0;left:34px}.dpad-down{bottom:0;left:34px}.dpad-left{top:34px;left:0}.dpad-right{top:34px;right:0}
.action-btns{display:flex;gap:10px;align-items:center}
.action-btn{width:48px;height:48px;border-radius:50%;font-weight:bold;font-size:14px}
.btn-a{background:linear-gradient(145deg,#cc2222,#991111);border:3px solid #ff4444;color:#fcc}
.btn-b{background:linear-gradient(145deg,#2255cc,#113399);border:3px solid #4477ff;color:#ccf;transform:translateY(12px)}
.action-btn:active{transform:scale(0.95)}.btn-b:active{transform:translateY(12px) scale(0.95)}
.menu-btns{display:flex;gap:16px}
.menu-btn{padding:6px 16px;border-radius:12px;background:#333;border:2px solid #555;color:#aaa;font-size:10px}
#info{color:#556;font-size:9px}
#debug{display:none;gap:6px;margin-top:8px;flex-wrap:wrap;justify-content:center}
#debug button{padding:4px 8px;font-size:9px;background:#222;border:1px solid #444;color:#888;border-radius:4px;cursor:pointer}
#debug button:hover{background:#333;color:#fff}
</style>
</head>
<body>
<div id="container">
<div id="screen"><canvas id="game" width="256" height="224"></canvas></div>
<div id="controls">
<div class="dpad">
<button class="dpad-btn dpad-up" data-key="up">▲</button>
<button class="dpad-btn dpad-left" data-key="left">◀</button>
<button class="dpad-btn dpad-right" data-key="right">▶</button>
<button class="dpad-btn dpad-down" data-key="down">▼</button>
</div>
<div class="action-btns">
<button class="action-btn btn-b" data-key="b">B</button>
<button class="action-btn btn-a" data-key="a">A</button>
</div>
</div>
<div class="menu-btns">
<button class="menu-btn" data-key="select">SELECT</button>
<button class="menu-btn" data-key="start">START</button>
</div>
<div id="info">CDW × CISCO Identity Security | v0.67</div>
<div id="debug"><button onclick="dbgTitle()">Title</button><button onclick="dbgLevel(1)">Lvl1</button><button onclick="dbgLevel(2)">Lvl2</button><button onclick="dbgLevel(3)">Lvl3</button><button onclick="dbgComplete()">Complete</button><button onclick="dbgVictory()">Victory</button><button onclick="dbgLose()">GameOver</button><button id="godBtn" onclick="toggleGodMode()" style="background:#440;border-color:#880;color:#aa0">GOD</button></div>
</div>

<script>
// ============================================================
// SUPER IDENTITY PARTNERS - v0.67
// CDW + Cisco Branded with Themed Enemies
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = 256, H = 224;
const TILE = 16;

// Brand Colors
const BRAND = {
  cdwRed: '#DC1E1E',
  cdwRedDark: '#A01515',
  ciscoBlue: '#049FD9',
  ciscoBlueDark: '#004BAF',
  duoGreen: '#74BF4B',
  duoGreenDark: '#4A8A2A',
};

// CDW Logo Image (80x50)
const cdwLogoImg = new Image();
cdwLogoImg.src = "data:image/png;base64,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";

function resize() {
  const maxW = window.innerWidth - 32;
  const maxH = window.innerHeight - 200;
  const scale = Math.min(Math.floor(maxW / W), Math.floor(maxH / H), 3);
  canvas.style.width = (W * Math.max(scale, 1)) + 'px';
  canvas.style.height = (H * Math.max(scale, 1)) + 'px';
}
resize();
window.addEventListener('resize', resize);

// ============================================================
// SMB3-STYLE PHYSICS
// ============================================================
const PHYSICS = {
  gravity: 0.20,          // Was 0.12 - 67% faster fall
  gravityHold: 0.12,      // Was 0.06 - 100% faster (key anti-float)
  maxFallSpeed: 4.5,      // Was 3.5 - faster terminal velocity
  walkAccel: 0.08,
  walkDecel: 0.10,
  runAccel: 0.12,
  skidDecel: 0.28,
  walkMaxSpeed: 1.5,
  runMaxSpeed: 2.5,
  maxSpeed: 3.0,
  airAccel: 0.05,
  airDecel: 0.03,
  jumpVelocity: -5.0,     // Was -4.0 - compensates for higher gravity
  jumpHoldTime: 14,       // Was 18 - tighter variable jump
  coyoteTime: 5,
  jumpBuffer: 6,
};

// ============================================================
// ============================================================
// GAME STATE
// ============================================================
let state = 'title';
let godMode = false;
let showCollision = false;
let exitLasersActive = true;
let exitUnlockTimer = 0;
let exitSeen = false;
let frame = 0;
let screenShake = 0;
let hitstop = 0;
let introScreen = 0;  // 0, 1, 2 for the 3 intro screens
let currentLevel = 1;
let maxLevels = 3;

// Enemy metadata for preview cards (matches level designer comments)
const enemyMeta = {
  0: { name: "MALICIOUS ATTACHMENT", desc: "Weaponized files that execute malware when opened" },
  1: { name: "CLICKBAIT", desc: "Deceptive links designed to harvest credentials" },
  2: { name: "HACKER", desc: "Exploits vulnerabilities for unauthorized access" },
  3: { name: "CREDENTIAL STUFFER", desc: "Automated attacks using stolen password databases" },
  4: { name: "SOCIAL ENGINEER", desc: "Manipulates users into bypassing security controls" },
  5: { name: "ROGUE ACCESS POINT", desc: "Fake wireless networks that intercept traffic" },
  6: { name: "PACKET SNIFFER", desc: "Captures unencrypted data traveling the network" },
  7: { name: "RANSOMWARE", desc: "Encrypts critical data and demands payment" },
  8: { name: "DATA EXFILTRATOR", desc: "Steals sensitive data and transmits externally" }
};

// Unique enemy types per level (from actual level data)
const levelEnemyTypes = {
  1: [0, 1, 3, 2],  // Malicious Attachment, Clickbait, Credential Stuffer, Hacker
  2: [5, 6, 4, 2],  // Rogue AP, Packet Sniffer, Social Engineer, Hacker
  3: [7, 8, 4, 2]   // Ransomware, Data Exfiltrator, Social Engineer, Hacker
};

let levelTransitionTimer = 0;

// ============================================================
// INPUT
// ============================================================
const input = { left: false, right: false, up: false, down: false, a: false, b: false, start: false };
const pressed = {};
const released = {};
const prevInput = {};

const KEYMAP = {
  ArrowLeft: 'left', ArrowRight: 'right', ArrowUp: 'up', ArrowDown: 'down',
  KeyA: 'left', KeyD: 'right', KeyW: 'up', KeyS: 'down',
  KeyZ: 'a', Space: 'a', KeyX: 'b', ShiftLeft: 'b', ShiftRight: 'b',
  Enter: 'start', Escape: 'start'
};

document.addEventListener('keydown', e => {
  const k = KEYMAP[e.code];
  if (k) { input[k] = true; e.preventDefault(); initAudio(); }
});
document.addEventListener('keyup', e => {
  const k = KEYMAP[e.code];
  if (k) input[k] = false;
});

// Debug key handlers
document.addEventListener('keydown', e => {
  if (e.key === "g" || e.key === "G") toggleGodMode();
  if (e.key === "c" || e.key === "C") {
    showCollision = !showCollision;
    console.log("Collision debug:", showCollision);
  }
});

document.querySelectorAll('[data-key]').forEach(btn => {
  const k = btn.dataset.key;
  const on = e => { e.preventDefault(); input[k] = true; initAudio(); };
  const off = e => { e.preventDefault(); input[k] = false; };
  btn.addEventListener('touchstart', on, { passive: false });
  btn.addEventListener('touchend', off, { passive: false });
  btn.addEventListener('touchcancel', off, { passive: false });
  btn.addEventListener('mousedown', on);
  btn.addEventListener('mouseup', off);
  btn.addEventListener('mouseleave', off);
});

function updateInput() {
  for (let k in input) {
    pressed[k] = input[k] && !prevInput[k];
    released[k] = !input[k] && prevInput[k];
    prevInput[k] = input[k];
  }
}

// ============================================================
// AUDIO
// ============================================================
let audioCtx = null;
let audioReady = false;

const music = {
  title: new Audio('music/title.ogg'),
  level1: new Audio('music/level.ogg'),
  level2: new Audio('music/level2.ogg'),
  level3: new Audio('music/victory.ogg'),
  win: new Audio('music/win.ogg'),
  victory: new Audio('music/level3.ogg'),
  lose: new Audio('music/lose.ogg')
};
let currentMusic = null;

function initAudio() {
  if (audioReady) return;
  audioReady = true;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  for (let k in music) {
    music[k].loop = true;
    music[k].volume = 0.35;  // QA FIX: reduced for SFX audibility
  }
  music.win.loop = false;
  music.lose.loop = false;
  playMusic('title');
}

function playMusic(track) {
  if (currentMusic) {
    currentMusic.pause();
    currentMusic.currentTime = 0;
  }
  currentMusic = music[track];
  if (currentMusic && audioReady) {
    currentMusic.play().catch(() => {});
  }
}

function stopMusic() {
  if (currentMusic) {
    currentMusic.pause();
    currentMusic.currentTime = 0;
  }
}

function sfx(freq, dur, type = 'square', vol = 0.18, slide = 0) {  // QA FIX: boosted
  if (!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.setValueAtTime(freq, audioCtx.currentTime);
  if (slide) o.frequency.exponentialRampToValueAtTime(Math.max(20, freq + slide), audioCtx.currentTime + dur);
  g.gain.setValueAtTime(vol, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + dur);
}

function noise(dur, vol = 0.10) {  // QA FIX: boosted
  if (!audioCtx) return;
  const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
  const n = audioCtx.createBufferSource();
  const g = audioCtx.createGain();
  n.buffer = buf;
  g.gain.setValueAtTime(vol, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  n.connect(g);
  g.connect(audioCtx.destination);
  n.start();
}

const SFX = {
  jump: () => { sfx(280, 0.08, 'square', 0.08); sfx(420, 0.1, 'square', 0.06, 100); },
  land: () => noise(0.04, 0.04),
  coin: () => { sfx(988, 0.05, 'square', 0.08); setTimeout(() => sfx(1319, 0.1, 'square', 0.1), 50); },
  powerup: () => { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => sfx(f, 0.1, 'square', 0.07), i * 60)); },
  stomp: () => { sfx(300, 0.06, 'square', 0.1, -150); noise(0.05, 0.06); },
  hurt: () => { sfx(200, 0.15, 'sawtooth', 0.1, -80); noise(0.1, 0.08); },
  bump: () => sfx(150, 0.06, 'square', 0.06),
  kick: () => { sfx(400, 0.04, 'square', 0.08); noise(0.03, 0.05); },
};

// ============================================================
// LEVEL METADATA
// ============================================================
const LEVEL_INFO = [
  null, // index 0 unused
  {
    name: "THE INBOX",
    zone: "CUSTOMER ZONE 1",
    challenge: "EMPLOYEES ARE BEING TARGETED.",
    solution: "DEPLOY MULTI-FACTOR AUTHENTICATION.",
    activating: "ACTIVATING DUO...",
    completeTitle: "MFA DEPLOYED",
    completeLines: ["CUSTOMER USERS NOW VERIFIED", "CREDENTIAL THEFT: BLOCKED"],
    completeFooter: "ZONE 1 SECURED",
  },
  {
    name: "THE PERIMETER",
    zone: "CUSTOMER ZONE 2",
    challenge: "UNKNOWN DEVICES ON THE NETWORK.",
    solution: "DEPLOY ACCESS CONTROL POLICIES.",
    activating: "ACTIVATING ISE...",
    completeTitle: "ACCESS POLICIES ENFORCED",
    completeLines: ["CUSTOMER DEVICES NOW VALIDATED", "ROGUE ENDPOINTS: QUARANTINED"],
    completeFooter: "ZONE 2 SECURED",
  },
  {
    name: "THE DATACENTER",
    zone: "CUSTOMER ZONE 3",
    challenge: "CRITICAL DATA REQUIRES",
    solution: "COMPLETE IDENTITY VERIFICATION.",
    activating: "DUO + ISE: SYNCHRONIZED",
    completeTitle: "ZERO TRUST ACHIEVED",
    completeLines: ["FULL IDENTITY VERIFICATION ACTIVE", "CUSTOMER DATA: PROTECTED"],
    completeFooter: "ZONE 3 SECURED",
  },
];

const INTRO_SCREENS = [
  {
    lines: [
      "CUSTOMER NETWORKS ARE UNDER ATTACK.",
      "",
      "PHISHING CAMPAIGNS TARGET",
      "EMPLOYEE CREDENTIALS.",
    ],
  },
  {
    lines: [
      "ROGUE DEVICES BYPASS",
      "PERIMETER DEFENSES.",
      "",
      "TRADITIONAL SECURITY HAS FAILED.",
    ],
  },
  {
    lines: [
      "CDW AND CISCO HAVE JOINED FORCES",
      "TO PROTECT WHAT MATTERS MOST.",
      "",
      "DEPLOY THE IDENTITY PROTOCOL.",
      "",
      "THEIR NETWORK. OUR MISSION.",
    ],
  },
];
// ============================================================
// LEVEL DATA
// ============================================================
// ============================================================
// LEVEL DATA (3 distinct levels)
// ============================================================
const LEVELS = [
  null, // index 0 unused
  
  // ============================================================
  // LEVEL 1: THE INBOX (DUO - User Authentication)  
  // DESKTOP WORLD - AAA Quality Level Design
  // ============================================================
  {
    width: 2400,
    ground: [
      // Section 1: TUTORIAL (0-300) - Safe start, learn basics
      [0, 180, 300],
      
      // Section 2: FIRST JUMP (364-600) - First gap challenge
      [364, 180, 236],
      
      // Section 3: PLATFORMS (664-900) - Learn platform jumping
      [664, 180, 236],
      
      // Section 4: COMBAT (964-1200) - Enemy gauntlet
      [964, 180, 236],
      
      // Section 5: VERTICALITY (1264-1500) - Multi-tier platforms
      [1264, 180, 236],
      
      // Section 6: CHALLENGE (1564-1800) - Combine all skills
      [1564, 180, 236],
      
      // Section 7: FINALE (1864-2400) - Victory run
      [1864, 180, 536],
    ],
    // Types: 0=sticky, 2=laptop, 4=mug, 5=stapler, 6=tape, 7=pencilcup
    platforms: [
      // === SECTION 1: Tutorial - learn jumping ===
      [140, 140, 32, 4],          // Mug - low (40px up)
      [220, 100, 56, 2],          // Laptop - mid (80px up)
      
      // === GAP 1: 300-364 ===
      
      // === SECTION 2: Building skill - ascending ===
      [400, 145, 40, 0],          // Sticky - low
      [470, 110, 32, 5],          // Stapler - mid
      [540, 70, 56, 2],           // Laptop - HIGH (110px up!)
      
      // === GAP 2: 600-664 ===
      
      // === SECTION 3: Ascending - staircase ===
      [700, 140, 32, 4],          // Mug - step 1
      [770, 105, 40, 6],          // Tape - step 2
      [850, 65, 56, 2],           // Laptop - step 3 HIGH
      
      // === GAP 3: 900-964 ===
      
      // === SECTION 4: Combat - varied heights ===
      [1000, 145, 40, 0],         // Sticky - low safe spot
      [1080, 100, 32, 7],         // Pencil cup - mid
      [1150, 55, 56, 2],          // Laptop - very high escape!
      
      // === GAP 4: 1200-1264 ===
      
      // === SECTION 5: Climb - the big ascent ===
      [1300, 140, 32, 4],         // Mug - step 1
      [1370, 110, 32, 5],         // Stapler - step 2
      [1440, 80, 40, 6],          // Tape - step 3
      [1510, 45, 56, 2],          // Laptop - SUMMIT! (135px up!)
      
      // === GAP 5: 1550-1614 ===
      
      // === SECTION 6: Challenge - mixed ===
      [1650, 145, 40, 0],         // Sticky - low
      [1720, 95, 32, 7],          // Pencil cup - mid-high
      [1790, 50, 56, 2],          // Laptop - very high
      
      // === GAP 6: 1850-1914 ===
      
      // === SECTION 7: Victory lap - celebratory heights ===
      [1950, 135, 32, 4],         // Mug - low
      [2020, 100, 40, 6],         // Tape - mid
      [2100, 60, 56, 2],          // Laptop - high
      [2180, 140, 40, 0],         // Victory sticky - easy finish
    ],
    // Blocks at y=128
    blocks: [
      [100, 100, 1, 1],           // Raised to y=100
      [520, 45, 1, 1],            // Raised, moved right - clear of stapler
      [820, 80, 1, 1],            // Higher
      [1045, 45, 1, 1],           // Moved left, raised - clear of pencil
      [1420, 35, 1, 1],           // Near summit - raised
      [1720, 40, 1, 1],           // High - raised above pencil
      [2080, 35, 1, 1],           // Moved right, raised - clear of tape
    ],
    // Tokens on platforms - none at spawn
    tokens: [
      // 25 tokens - ALL VERIFIED with 20px+ buffer from objects
      // Collision-checked against all platforms and blocks
      
      // Section 1: TUTORIAL (0-300)
      [120, 164],                   // Ground
      [180, 115],                  // Mid - between mug(172)/laptop(220)
      [290, 70],                   // High - after laptop(276)
      
      // Section 2: FIRST JUMP (364-600)
      [370, 164],                  // Ground - before sticky(400)
      [445, 85],                   // High - between sticky(440)/stapler(470)
      [620, 45],                   // High - gap after laptop
      [630, 100],                  // Mid - gap after laptop
      
      // Section 3: PLATFORMS (664-900)
      [685, 164],                  // Ground - before mug(700)
      [758, 80],                   // Mid - between mug(732)/tape(770)
      [940, 45],                   // High - gap after laptop
      [950, 110],                  // Mid - gap after laptop
      
      // Section 4: COMBAT (964-1200)
      [975, 164],                  // Ground - before sticky(1000)
      [1140, 30],                  // Very high - before laptop(1150)
      [1240, 80],                  // Mid - gap after laptop
      [1250, 130],                 // Low-mid - gap after laptop
      
      // Section 5: VERTICALITY (1264-1500)
      [1275, 164],                 // Ground - before mug(1300)
      [1358, 85],                  // Mid - between mug(1332)/stapler(1370)
      [1595, 25],                  // SUMMIT BONUS - after laptop(1566)
      [1605, 100],                 // Mid - after summit
      
      // Section 6: CHALLENGE (1564-1800)
      [1610, 130],                 // Mid - safe zone
      [1875, 30],                  // High - after laptop(1846)
      [1885, 100],                 // Mid - after laptop
      
      // Section 7: FINALE (1864-2400)
      [1915, 160],                 // Ground - before mug(1950)
      [2010, 130],                 // Mid - between mug(1982)/tape(2020)
      [2260, 50],                  // High - after sticky(2220)
    ],
    // Enemies on ground (y=160 for proper positioning)
    enemies: [
      // 20 ENEMIES - ground + raised LAPTOP platforms
      // Laptops now HIGH in the air for real platforming challenge!
      
      // Section 1: Safe spawn (0-300) - NO enemies
      
      // Section 2: (364-600) - 3 enemies
      [380, 160, 0, 364, 399],          // 1. Phishing (ground)
      [455, 160, 1, 441, 469],          // 2. Data Breach (ground)
      [570, 54, 3, 540, 596],           // 3. Mal Attachment (LAPTOP y=70)
      
      // Section 3: (664-900) - 3 enemies
      [680, 160, 4, 664, 699],          // 4. Social Engineer (ground)
      [750, 160, 0, 733, 769],          // 5. Phishing (ground)
      [880, 49, 1, 850, 906],           // 6. Data Breach (LAPTOP y=65)
      
      // Section 4: (964-1200) - 3 enemies
      [980, 160, 3, 964, 999],          // 7. Mal Attachment (ground)
      [1060, 160, 4, 1041, 1079],       // 8. Social Engineer (ground)
      [1180, 39, 0, 1150, 1206],        // 9. Phishing (LAPTOP y=55)
      
      // Section 5: (1264-1500) - 3 enemies
      [1280, 160, 1, 1264, 1299],       // 10. Data Breach (ground)
      [1350, 160, 3, 1333, 1369],       // 11. Mal Attachment (ground)
      [1540, 29, 4, 1510, 1566],        // 12. Social Engineer (SUMMIT LAPTOP y=45!)
      
      // Section 6: (1564-1800) - 3 enemies
      [1610, 160, 0, 1564, 1649],       // 13. Phishing (ground)
      [1705, 160, 1, 1691, 1719],       // 14. Data Breach (ground)
      [1820, 34, 3, 1790, 1846],        // 15. Mal Attachment (LAPTOP y=50)
      
      // Section 7: (1864-2400) - 5 enemies
      [1910, 160, 4, 1864, 1949],       // 16. Social Engineer (ground)
      [2000, 160, 0, 1983, 2019],       // 17. Phishing (ground)
      [2130, 44, 1, 2100, 2156],        // 18. Data Breach (LAPTOP y=60)
      [2165, 160, 3, 2157, 2179],       // 19. Mal Attachment (ground)
      [2300, 160, 4, 2221, 2390],       // 20. Social Engineer (ground)
    ],
    pipes: [],
    playerStart: [32, 160],
    checkpoints: [[1264, 164]],
    // Desktop World disabled
  },

  // ============================================================
  // LEVEL 2: THE PERIMETER (ISE - Device Trust)
  // CLEAN DESIGN - no overlaps, safe spawn
  // ============================================================
  {
    width: 2000,
    ground: [
      // All gaps are 80px for platforms
      [0, 192, 240],           // 0-240 (START - wide safe zone)
      [320, 128, 120],         // 320-440 (TOWER TOP)
      [520, 112, 120],         // 520-640 (CROSSING)
      [720, 192, 160],         // 720-880 (PIT)
      [960, 160, 120],         // 960-1080 (REST)
      [1160, 128, 120],        // 1160-1280 (CLIMB)
      [1360, 80, 200],         // 1360-1560 (SUMMIT)
      [1640, 128, 120],        // 1640-1760 (DESCENT 1)
      [1840, 192, 160],        // 1840-2000 (EXIT)
    ],
    platforms: [
      // TOWER CLIMB - in gap 240-320
      [256, 160, 48],          // Step 1
      [256, 128, 48],          // Step 2
      // GAP BRIDGES ONLY - centered in 80px gaps
      [456, 120, 48],          // Gap 440-520
      [656, 176, 48],          // Gap 640-720
      [896, 144, 48],          // Gap 880-960
      [1096, 144, 48],         // Gap 1080-1160
      [1296, 104, 48],         // Gap 1280-1360
      [1576, 112, 48],         // Gap 1560-1640
      [1776, 160, 48],         // Gap 1760-1840
    ],
    blocks: [
      // Spaced 80px+ apart
      [80, 144, 1, 1],         // Start
      [380, 80, 1, 1],         // Tower
      [580, 64, 1, 0],         // Crossing
      [800, 144, 1, 1],        // Pit
      [1020, 112, 1, 0],       // Rest
      [1220, 80, 1, 1],        // Climb
      [1440, 32, 1, 1],        // Summit
      [1700, 80, 1, 0],        // Descent
      [1870, 144, 1, 1],       // Before exit gate
    ],
    tokens: [
      // L2: 25 tokens - safe from edges (50px buffer) and gate
      // START (0-240, y=192)
      [100, 176], [160, 140],
      // Tower platform (256-304, y=160)
      [270, 144], [290, 100],
      // TOWER (320-440, y=128)
      [350, 112], [410, 80],
      // Bridge (456-504, y=120)
      [480, 104],
      // CROSSING (520-640, y=112)
      [550, 96], [610, 70],
      // Bridge (656-704, y=176)
      [680, 160],
      // PIT (720-880, y=192) - keep away from edge at 880!
      [770, 176], [820, 150],
      // Bridge (896-944, y=144)
      [920, 128],
      // REST (960-1080, y=160)
      [1050, 144],
      // Bridge (1096-1144, y=144)
      [1120, 128],
      // CLIMB (1160-1280, y=128)
      [1200, 112], [1250, 80],
      // Bridge (1296-1344, y=104)
      [1320, 88],
      // SUMMIT (1360-1560, y=80)
      [1420, 64], [1500, 45],
      // Bridge (1576-1624, y=112)
      [1600, 96],
      // DESCENT (1640-1760, y=128)
      [1670, 112], [1730, 90],
      // Bridge (1776-1824, y=160)
      [1800, 144],
      // EXIT (1840-2000, y=192) - BEFORE gate at 1900!
      [1880, 176],
    ],
    enemies: [
      // L2: 15 ENEMIES - patrol ranges STRICTLY within ground segments
      // Format: [x, y, type, minX, maxX]
      
      // START (0-240, ground y=192)
      [100, 176, 4, 20, 155],              // 1. Social Engineer
      
      // TOWER TOP (320-440, ground y=128)
      [380, 112, 5, 340, 420],             // 2. Rogue AP
      
      // CROSSING (520-640, ground y=112)
      [560, 96, 6, 540, 620],              // 3. Packet Sniffer
      
      // PIT (720-880, ground y=192)
      [780, 176, 2, 755, 860],             // 4. Hacker
      [840, 176, 4, 800, 860],             // 5. Social Engineer
      
      // REST (960-1080, ground y=160)
      [1030, 144, 5, 995, 1060],           // 6. Rogue AP
      
      // CLIMB (1160-1280, ground y=128)
      [1200, 112, 6, 1180, 1260],          // 7. Packet Sniffer
      
      // SUMMIT (1360-1560, ground y=80) - biggest area, 3 enemies
      [1420, 64, 2, 1395, 1540],           // 8. Hacker
      [1480, 64, 5, 1440, 1540],           // 9. Rogue AP
      
      // DESCENT (1640-1760, ground y=128)
      [1680, 112, 4, 1660, 1740],          // 10. Social Engineer
      
      // EXIT (1840-2000, ground y=192)
      [1900, 176, 6, 1875, 1980],          // 11. Packet Sniffer
      [1950, 176, 5, 1920, 1980],          // 12. Rogue AP
      
      // Extra enemies for difficulty - spread evenly
      [580, 96, 2, 540, 620],              // 13. Hacker (CROSSING)
      [1040, 144, 6, 995, 1070],           // 14. Packet Sniffer (REST)
      [1200, 112, 4, 1180, 1260],          // 15. Social Engineer (CLIMB)
    ],
    pipes: [
      // Landmarks - all 80px+ from blocks
      [180, 160, 32],          // Start
      [720, 160, 48],          // Before pit
      [960, 128, 56],          // REST
      [1360, 48, 64],          // SUMMIT (tall!)
      [1840, 160, 32],         // Exit
    ],
    playerStart: [40, 176],
    checkpoints: [[1020, 144]],
  },
  // LEVEL 3: DATACENTER (Zero Trust - Full Protection)
  // CLEAN DESIGN - no overlaps, safe spawn
  // ============================================================
  {
    width: 3200,
    ground: [
      // LEVEL 3: THE GAUNTLET - Stark height differences, no crutch platforms
      // Jump capability: ~64px height, ~80px distance
      // Height differences: 48-56px (challenging but possible)
      
      // SECTION 1: THE CLIMB (0-1200)
      [0, 192, 200],           // 0-200 (START - safe zone)
      [264, 136, 200],         // 264-464 (LEAP UP - 56px climb!)
      [528, 80, 200],          // 528-728 (SUMMIT - 56px more!)
      [792, 136, 200],         // 792-992 (DROP DOWN - 56px fall)
      
      // SECTION 2: THE VALLEY (1056-1800) - CHECKPOINT
      [1056, 192, 200],        // 1056-1256 (VALLEY FLOOR)
      [1320, 144, 200],        // 1320-1520 (RISE - 48px)
      [1584, 96, 200],         // 1584-1784 (HIGH PLATEAU - 48px)
      
      // SECTION 3: THE FINALE (1848-3200) - CHECKPOINT
      [1848, 144, 200],        // 1848-2048 (DROP - 48px)
      [2112, 192, 200],        // 2112-2312 (GROUND LEVEL)
      [2376, 136, 200],        // 2376-2576 (FINAL CLIMB - 56px)
      [2640, 80, 200],         // 2640-2840 (PEAK 2 - 56px!)
      [2904, 144, 200],        // 2904-3104 (DESCENT)
      [3104, 192, 96],         // 3104-3200 (EXIT)
    ],
    platforms: [
      // L3: NO thin platforms - raw ground-to-ground jumps only
    ],
    blocks: [
      // L3 GAUNTLET blocks - block_y = ground_y - 48
      // SECTION 1: THE CLIMB
      [100, 144, 1, 1],        // START (0-200, ground=192)
      [350, 88, 1, 0],         // LEAP UP (264-464, ground=136)
      [600, 32, 1, 1],         // SUMMIT (528-728, ground=80) - highest block!
      [880, 88, 1, 0],         // DROP (792-992, ground=136)
      // SECTION 2: THE VALLEY
      [1150, 144, 1, 1],       // VALLEY (1056-1256, ground=192)
      [1420, 96, 1, 0],        // RISE (1320-1520, ground=144)
      [1680, 48, 1, 1],        // HIGH (1584-1784, ground=96)
      // SECTION 3: THE FINALE
      [1940, 96, 1, 0],        // DROP (1848-2048, ground=144)
      [2200, 144, 1, 1],       // GROUND (2112-2312, ground=192)
      [2460, 88, 1, 0],        // CLIMB (2376-2576, ground=136)
      [2720, 32, 1, 1],        // PEAK 2 (2640-2840, ground=80) - highest!
      [2940, 96, 1, 1],        // DESCENT (2904-3104, ground=144) (3104-3200, ground=192)
    ],
    tokens: [
      // L3 GAUNTLET: 25 tokens - stark terrain challenge
      // SECTION 1: THE CLIMB (4 tokens)
      [80, 176],               // E: START (ground=192)
      [140, 130],              // M: safe jump challenge
      [350, 120],              // E: LEAP UP (ground=136)
      [600, 64],               // E: SUMMIT (ground=80) - first peak!
      [700, 30],               // H: CROWN JEWEL #1 - 50px jump!
      [440, 85],               // M: jump on LEAP UP
      [880, 120],              // E: DROP (ground=136)
      [950, 85],               // M: jump challenge on DROP
      
      // SECTION 2: THE VALLEY (6 tokens)
      [1080, 176],             // E: VALLEY (ground=192)
      [1180, 145],             // M: medium jump
      [1380, 128],             // E: RISE (ground=144)
      [1480, 96],              // M: harder jump
      [1650, 80],              // E: HIGH (ground=96)
      [1750, 45],              // H: CROWN JEWEL #2 - 51px jump!
      
      // SECTION 3: THE FINALE (13 tokens - gauntlet!)
      [1900, 128],             // E: DROP (ground=144)
      [1980, 96],              // M: jump before valley
      [2160, 176],             // E: GROUND (ground=192)
      [2280, 145],             // M: medium jump
      [2420, 120],             // E: CLIMB (ground=136)
      [2540, 85],              // M: harder jump
      [2700, 64],              // E: PEAK 2 (ground=80)
      [2810, 30],              // H: CROWN JEWEL #3 - hardest!
      [2950, 128],             // E: DESCENT (ground=144)
      [3020, 100],             // M: final jump challenge (ground=144)
      [2220, 145],             // E: GROUND LEVEL (ground=192) (ground=192)
    ],
    enemies: [
      // L3 GAUNTLET: 20 ENEMIES - stark terrain, enemy_y = ground_y - 16
      // SECTION 1: THE CLIMB
      [160, 176, 7, 130, 195],         // 1. Ransomware (START 0-200, ground=192)
      [350, 120, 4, 274, 454],         // 2. Social Engineer (264-464, ground=136)
      [580, 64, 8, 538, 640],          // 3. Data Exfiltrator (528-728, ground=80) SUMMIT!
      [700, 64, 2, 690, 718],          // 4. Hacker (528-728, ground=80)
      [880, 120, 7, 802, 982],         // 5. Ransomware (792-992, ground=136)
      
      // SECTION 2: THE VALLEY
      [1120, 176, 4, 1090, 1180],      // 6. Social Engineer (1056-1256, ground=192)
      [1160, 176, 8, 1130, 1180],      // 7. Data Exfiltrator (1056-1256, ground=192) (1056-1256, ground=192)
      [1400, 128, 8, 1330, 1510],      // 7. Data Exfiltrator (1320-1520, ground=144)
      [1480, 128, 7, 1330, 1510],      // 8. Ransomware (1320-1520, ground=144)
      [1680, 80, 2, 1594, 1774],       // 9. Hacker (1584-1784, ground=96) HIGH!
      [1740, 80, 7, 1700, 1774],       // 10. Ransomware (1584-1784, ground=96) (1584-1784, ground=96) HIGH!
      
      // SECTION 3: THE FINALE
      [1940, 128, 4, 1910, 2038],      // 10. Social Engineer (1848-2048, ground=144)
      [2200, 176, 8, 2122, 2302],      // 11. Data Exfiltrator (2112-2312, ground=192)
      [2280, 176, 4, 2200, 2302],      // 12. Social Engineer (2112-2312, ground=192) (2112-2312, ground=192)
      [2460, 120, 7, 2386, 2566],      // 12. Ransomware (2376-2576, ground=136)
      [2540, 120, 2, 2386, 2566],      // 13. Hacker (2376-2576, ground=136)
      [2700, 64, 4, 2650, 2740],       // 14. Social Engineer (2640-2840, ground=80) PEAK 2!
      [2810, 64, 8, 2790, 2830],       // 15. Data Exfiltrator (2640-2840, ground=80)
      [2980, 128, 7, 2914, 3094],      // 16. Ransomware (2904-3104, ground=144)
      [3050, 128, 2, 2914, 3094],      // 17. Hacker (2904-3104, ground=144)
    ],
    pipes: [
      // L3 GAUNTLET pipes - landmarks at key transitions
      [650, 48, 32],           // SUMMIT (ground=80) - tall!
      [1200, 160, 32],         // VALLEY (ground=192)
      [2750, 48, 32],          // PEAK 2 (ground=80) - tall!
    ],
    playerStart: [60, 176],
    checkpoints: [[1080, 176], [1900, 128]],
  },
];

// Current level reference (set by initLevel)
let level = LEVELS[1];
// Level visual themes - LANDSCAPE EDITION
const LEVEL_THEMES = [
  null,
  { // Level 1: THE INBOX - Corporate Skyline at Dawn
    name: "THE INBOX",
    // Dawn sky palette
    skyTop: "#1a1a3a",      // Deep blue-purple
    skyMid: "#4a3a5a",      // Dusty purple  
    skyHorizon: "#ff9966",  // Warm orange
    skyGlow: "#ffcc88",     // Sun glow
    // Silhouette colors (dark to light by distance)
    farSilhouette: "#0a0a1a",
    midSilhouette: "#151525", 
    nearSilhouette: "#202035",
    // Accent
    windowGlow: "#ffeeaa",
    accentLight: "#ff6644",
  },
  { // Level 2: THE PERIMETER - Digital Void
    name: "THE PERIMETER",
    // Cyber void palette
    skyTop: "#000005",
    skyMid: "#000510",
    skyHorizon: "#001520",
    skyGlow: "#003040",
    // Grid and structures
    farSilhouette: "#001015",
    midSilhouette: "#002025",
    nearSilhouette: "#003035",
    // Cyan accents
    gridLine: "#00ffff",
    accentLight: "#00ff88",
    glowColor: "rgba(0,255,255,0.15)",
  },
  { // Level 3: DATACENTER - Underground Cathedral
    name: "THE DATACENTER",
    // Dark industrial palette
    skyTop: "#050508",
    skyMid: "#080810",
    skyHorizon: "#0a0a15",
    skyGlow: "#101020",
    // Server silhouettes
    farSilhouette: "#08080c",
    midSilhouette: "#0c0c12",
    nearSilhouette: "#101018",
    // Warning accents
    accentLight: "#ff4444",
    warningGlow: "rgba(255,50,50,0.1)",
    ledGreen: "#00ff44",
    ledAmber: "#ffaa00",
  },
];




// ============================================================
// PLAYER
// ============================================================
let player = {
  x: 32, y: 160,
  vx: 0, vy: 0,
  width: 12, height: 20,
  grounded: false,
  facing: 1,
  big: false,
  animFrame: 0,
  animTimer: 0,
  squashX: 1,
  squashY: 1,
  coyoteTimer: 0,
  jumpBufferTimer: 0,
  jumpHoldTimer: 0,
  isJumping: false,
  pMeter: 0,
  pMeterMax: 70,
  invincible: 0,
  skidding: false,
};

let camera = { x: 0, targetX: 0 };
let lives = 5;
let coins = 0;
let tokens = [];
let collectedTokens = 0;
let checkpointReached = -1;
let checkpointTokens = 0;
let allTokensNotified = false;
  exitLasersActive = true;
  exitUnlockTimer = 0;
  exitSeen = false;
let blocks = [];
let enemies = [];
let powerups = [];
let particles = [];  // Game VFX (coin bursts, etc.)
let floatingTexts = [];

// ============================================================
// INITIALIZATION
// ============================================================
function initLevel() {
  // Set current level data
  level = LEVELS[currentLevel];
  player.x = level.playerStart[0];
  player.y = level.playerStart[1];
  player.vx = 0;
  player.vy = 0;
  player.grounded = false;
  player.big = false;
  player.invincible = 0;
  player.pMeter = 0;
  player.coyoteTimer = 0;
  player.jumpBufferTimer = 0;
  player.jumpHoldTimer = 0;
  player.isJumping = false;
  player.squashX = 1;
  player.squashY = 1;
  
  camera.x = 0;
  camera.targetX = 0;
  collectedTokens = 0;
  checkpointReached = -1;
  checkpointTokens = 0;
  allTokensNotified = false;
  exitLasersActive = true;
  exitUnlockTimer = 0;
  exitSeen = false;
  coins = 0;
  
  tokens = level.tokens.map(([x, y]) => ({ x, y, collected: false, anim: Math.random() * 100 }));
  
  // QA FIX: Only include mystery blocks that contain powerups (contents === 1)
  blocks = level.blocks
    .filter(([x, y, type, contents]) => contents === 1)  // Remove empty blocks
    .map(([x, y, type, contents]) => ({
      x, y, type, contents,
      bounceTimer: 0,
      coinTimer: contents === 2 ? 5 : 0,
    }));
  
  // Enemies with themed types
  enemies = level.enemies.map(([x, y, type, minX, maxX]) => ({
    x, y, type, minX, maxX,
    vx: type === 1 ? -0.5 : -0.35, // SLOWED DOWN
    alive: true,
    stompTimer: 0,
    animTimer: 0,
    state: 'patrol',
    alertTimer: 0,
    // New enemy properties
    baseY: y,           // For bouncing enemies (type 4)
    lungeVx: 0,         // For credential stealer (type 3)
    lungeTimer: 0,
    cooldownTimer: 0,
    bounceTimer: 0,     // For malicious attachment (type 4)
    pulseTimer: 0,      // For rogue AP (type 5)
    dangerRadius: 28,
    pathHistory: [],    // For packet sniffer (type 6)
    pathDelay: 60,
    // Credential Stealer (type 3) fly-over properties
    flyTimer: 0,
    targetX: 0,
    hesitateTimer: 0,
    approachTimer: 0,
  }));
  
  powerups = [];
  particles = [];
  floatingTexts = [];
  
  // Initialize visual feast particle system
}

// ============================================================
// COLLISION
// ============================================================
function rectOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

function getTileCollision(x, y, w, h) {
  for (const [gx, gy, gw] of level.ground) {
    if (rectOverlap(x, y, w, h, gx, gy, gw, 32)) {
      return { type: 'ground', x: gx, y: gy, w: gw, h: 32 };
    }
  }
  for (const b of blocks) {
    if (b.type >= 0 && rectOverlap(x, y, w, h, b.x, b.y, 16, 16)) {
      return { type: 'block', block: b, x: b.x, y: b.y, w: 16, h: 16 };
    }
  }
  for (const [px, py, ph] of level.pipes) {
    if (rectOverlap(x, y, w, h, px, py, 32, ph)) {
      return { type: 'pipe', x: px, y: py, w: 32, h: ph };
    }
  }
  return null;
}

// Helper: Check if there's ground at a given X position for enemy edge detection
function hasGroundAt(x, y) {
  // Check main ground
  for (const [gx, gy, gw] of level.ground) {
    if (x >= gx && x <= gx + gw && y >= gy - 4 && y <= gy + 8) {
      return true;
    }
  }
  // Check platforms
  for (const [px, py, pw] of level.platforms) {
    if (x >= px && x <= px + pw && y >= py - 4 && y <= py + 8) {
      return true;
    }
  }
  return false;
}

// Helper: Check if enemy would hit a solid obstacle (pipe, block) at position
function enemyHitsObstacle(x, y, w, h) {
  // Check pipes
  for (const [px, py, ph] of level.pipes) {
    if (x < px + 32 && x + w > px && y < py + ph && y + h > py) {
      return true;
    }
  }
  // Check solid blocks
  for (const b of blocks) {
    if (b.type >= 0) {  // Only solid blocks
      if (x < b.x + 16 && x + w > b.x && y < b.y + 16 && y + h > b.y) {
        return true;
      }
    }
  }
  return false;
}

function getPlatformCollision(x, y, w, h, vy) {
  if (vy <= 0) return null;
  for (const [px, py, pw] of level.platforms) {
    if (rectOverlap(x, y, w, h, px, py, pw, 8)) {
      if (y + h - vy <= py + 4) {
        return { x: px, y: py, w: pw };
      }
    }
  }
  return null;
}

// ============================================================
// PLAYER UPDATE
// ============================================================
function updatePlayer() {
  if (hitstop > 0) return;
  
  const P = PHYSICS;
  const ph = player.big ? 28 : 20;
  const pw = player.width;
  
  if (player.invincible > 0) player.invincible--;
  if (godMode) player.invincible = 999;
  
  // Horizontal movement
  const isRunning = input.b;
  const maxSpeed = isRunning ? P.runMaxSpeed : P.walkMaxSpeed;
  const accel = player.grounded ? (isRunning ? P.runAccel : P.walkAccel) : P.airAccel;
  
  const wantLeft = input.left && !input.right;
  const wantRight = input.right && !input.left;
  const movingLeft = player.vx < -0.1;
  const movingRight = player.vx > 0.1;
  
  player.skidding = false;
  
  if (wantLeft) {
    player.facing = -1;
    if (movingRight && player.grounded) {
      player.skidding = true;
      player.vx -= P.skidDecel;
    } else {
      player.vx -= accel;
    }
  } else if (wantRight) {
    player.facing = 1;
    if (movingLeft && player.grounded) {
      player.skidding = true;
      player.vx += P.skidDecel;
    } else {
      player.vx += accel;
    }
  } else {
    if (player.grounded) {
      player.vx *= (1 - P.walkDecel);
    } else {
      player.vx *= (1 - P.airDecel);
    }
  }
  
  if (player.vx > maxSpeed) player.vx = maxSpeed;
  if (player.vx < -maxSpeed) player.vx = -maxSpeed;
  if (Math.abs(player.vx) < 0.05) player.vx = 0;
  
  // P-Meter
  if (player.grounded && isRunning && Math.abs(player.vx) > P.walkMaxSpeed * 0.9) {
    player.pMeter = Math.min(player.pMeterMax, player.pMeter + 1);
  } else if (!isRunning || Math.abs(player.vx) < P.walkMaxSpeed * 0.5) {
    player.pMeter = Math.max(0, player.pMeter - 2);
  }
  
  // Coyote time
  if (player.grounded) {
    player.coyoteTimer = P.coyoteTime;
  } else if (player.coyoteTimer > 0) {
    player.coyoteTimer--;
  }
  
  // Jump buffer
  if (pressed.a) {
    player.jumpBufferTimer = P.jumpBuffer;
  } else if (player.jumpBufferTimer > 0) {
    player.jumpBufferTimer--;
  }
  
  // Jump
  if (player.jumpBufferTimer > 0 && player.coyoteTimer > 0) {
    const speedBonus = Math.abs(player.vx) * 0.08;
    player.vy = P.jumpVelocity - speedBonus;
    player.isJumping = true;
    player.jumpHoldTimer = P.jumpHoldTime;
    player.grounded = false;
    player.coyoteTimer = 0;
    player.jumpBufferTimer = 0;
    player.squashX = 0.7;
    player.squashY = 1.3;
    SFX.jump();
  }
  
  if (player.isJumping && input.a && player.jumpHoldTimer > 0) {
    player.jumpHoldTimer--;
  } else {
    player.isJumping = false;
    player.jumpHoldTimer = 0;
  }
  
  // Gravity
  const grav = (player.isJumping && input.a && player.vy < 0) ? P.gravityHold : P.gravity;
  player.vy += grav;
  if (player.vy > P.maxFallSpeed) player.vy = P.maxFallSpeed;
  
  // Move X
  player.x += player.vx;
  
  let col = getTileCollision(player.x, player.y, pw, ph);
  if (col) {
    if (player.vx > 0) player.x = col.x - pw;
    else if (player.vx < 0) player.x = col.x + col.w;
    player.vx = 0;
  }
  
  // Move Y
  player.y += player.vy;
  
  player.grounded = false;
  col = getTileCollision(player.x, player.y, pw, ph);
  if (col) {
    if (player.vy > 0) {
      player.y = col.y - ph;
      if (player.vy > 2) {
        player.squashX = 1.2;
        player.squashY = 0.8;
        SFX.land();
      }
      player.vy = 0;
      player.grounded = true;
      player.isJumping = false;
    } else if (player.vy < 0) {
      player.y = col.y + col.h;
      player.vy = 0;
      if (col.type === 'block') hitBlock(col.block);
      SFX.bump();
    }
  }
  
  // Platform collision
  if (player.vy > 0) {
    const plat = getPlatformCollision(player.x, player.y, pw, ph, player.vy);
    if (plat) {
      player.y = plat.y - ph;
      if (player.vy > 2) {
        player.squashX = 1.2;
        player.squashY = 0.8;
        SFX.land();
      }
      player.vy = 0;
      player.grounded = true;
      player.isJumping = false;
    }
  }
  
  // World bounds
  if (player.x < 0) player.x = 0;
  if (player.x > level.width - pw) player.x = level.width - pw;
  
  // Checkpoint detection (QA FIX: added flag activation)
  if (level.checkpoints) {
    for (let i = 0; i < level.checkpoints.length; i++) {
      if (i > checkpointReached) {
        const cp = level.checkpoints[i];
        if (player.x >= cp[0] - 20 && player.x <= cp[0] + 20) {
          checkpointReached = i;
          checkpointTokens = collectedTokens;
          floatingTexts.push({ x: cp[0], y: cp[1] - 40, text: 'CHECKPOINT!', timer: 90, vy: -0.5 });
          SFX.powerup();
        }
      }
    }
  }

  // Exit zone check - must collect ALL tokens
  const exitX = level.width - 80;
  const allTokensCollected = collectedTokens >= tokens.length;
  if (player.x >= exitX && allTokensCollected) {
    state = 'levelComplete';
    levelTransitionTimer = 0;
    playMusic('win');
  }
  
  // Fall death
  if (player.y > H + 32) die();
  
  // Squash recovery
  player.squashX += (1 - player.squashX) * 0.3;
  player.squashY += (1 - player.squashY) * 0.3;
  
  // Animation
  if (player.grounded) {
    if (player.skidding) {
      player.animFrame = 4;
    } else if (Math.abs(player.vx) > 0.3) {
      player.animTimer += Math.abs(player.vx) * 0.4;
      if (player.animTimer > 4) {
        player.animTimer = 0;
        player.animFrame = (player.animFrame + 1) % 4;
      }
    } else {
      player.animFrame = 0;
    }
  } else {
    player.animFrame = player.vy < 0 ? 5 : 6;
  }
  
  // Token collection (DUO MFA tokens)
  for (const t of tokens) {
    if (t.collected) continue;
    if (rectOverlap(player.x, player.y, pw, ph, t.x, t.y, 14, 14)) {
      t.collected = true;
      collectedTokens++;
      SFX.coin();
      spawnParticles(t.x + 7, t.y + 7, BRAND.duoGreen, 8);
      floatingTexts.push({ x: t.x, y: t.y, text: 'MFA+', timer: 40, vy: -1 });
      
      if (collectedTokens === tokens.length && !allTokensNotified) {
        allTokensNotified = true;
        floatingTexts.push({ x: player.x, y: player.y - 32, text: 'EXIT UNLOCKED!', timer: 90, vy: -0.5 });
        SFX.powerup();
      }
    }
  }
  
// Powerup collection (Firewall Shield)
  for (let i = powerups.length - 1; i >= 0; i--) {
    const pu = powerups[i];
    if (rectOverlap(player.x, player.y, pw, ph, pu.x, pu.y, 14, 14)) {
      powerups.splice(i, 1);
      if (player.big) {
        // Already shielded - grant extra life instead
        lives++;
        SFX.powerup();
        spawnParticles(pu.x + 7, pu.y + 7, '#ff6b9d', 12);
        floatingTexts.push({ x: pu.x, y: pu.y - 8, text: '+1 LIFE!', timer: 50, vy: -1 });
      } else {
        player.big = true;
        player.y -= 8;
        SFX.powerup();
        spawnParticles(pu.x + 7, pu.y + 7, getShieldInfo().color, 12);
        floatingTexts.push({ x: pu.x, y: pu.y - 8, text: getShieldInfo().name + ' SHIELD!', timer: 50, vy: -1 });
      }
    }
  }
}

function hitBlock(block) {
  if (block.type === 2) return;
  
  block.bounceTimer = 8;
  
  // Kill enemies standing on this block (bump from below)
  for (const e of enemies) {
    if (!e.alive) continue;
    // Check if enemy is on top of this block
    if (e.x + 16 > block.x && e.x < block.x + 16 &&
        e.y + 16 >= block.y - 4 && e.y + 16 <= block.y + 4) {
      e.alive = false;
      e.stompTimer = 15;
      SFX.kick();
      screenShake = 4;
      spawnParticles(e.x + 8, e.y + 8, "#ff4444", 10);
      floatingTexts.push({ x: e.x, y: e.y - 8, text: "BLOCKED!", timer: 40, vy: -1 });
    }
  }
  
  if (block.type === 1) {
    block.type = 2;
    
    if (block.contents === 1) {
      powerups.push({ x: block.x + 1, y: block.y - 16, timer: 0 });
    } else if (block.contents === 2 && block.coinTimer > 0) {
      block.coinTimer--;
      if (block.coinTimer > 0) block.type = 1;
      coins++;
      SFX.coin();
      spawnParticles(block.x + 8, block.y - 8, '#ffcc00', 6);
    } else {
      coins++;
      SFX.coin();
      spawnParticles(block.x + 8, block.y - 8, '#ffcc00', 6);
    }
  } else if (block.type === 0 && player.big) {
    block.type = -1;
    SFX.kick();
    screenShake = 4;
    for (let i = 0; i < 4; i++) {
      particles.push({
        x: block.x + 8, y: block.y + 8,
        vx: (Math.random() - 0.5) * 4,
        vy: -Math.random() * 4 - 2,
        life: 30, color: '#c84c0c', gravity: true, size: 4
      });
    }
  }
}

// ============================================================
// ENEMY UPDATE
// ============================================================
function updateEnemies() {
  if (hitstop > 0) return;
  
  const ph = player.big ? 28 : 20;
  const pw = player.width;
  
  for (const e of enemies) {
    if (!e.alive) continue;
    
    // Push enemy out of any obstacles they're currently inside
    if (enemyHitsObstacle(e.x, e.y, 16, 16)) {
      // Try pushing left
      let pushed = false;
      for (let i = 1; i <= 20; i++) {
        if (!enemyHitsObstacle(e.x - i, e.y, 16, 16)) {
          e.x -= i;
          e.vx = -Math.abs(e.vx);  // Move away from obstacle
          pushed = true;
          break;
        }
      }
      // If left didn't work, try right
      if (!pushed) {
        for (let i = 1; i <= 20; i++) {
          if (!enemyHitsObstacle(e.x + i, e.y, 16, 16)) {
            e.x += i;
            e.vx = Math.abs(e.vx);
            break;
          }
        }
      }
    }
    
    e.animTimer++;
    
    if (e.stompTimer > 0) {
      e.stompTimer--;
      if (e.stompTimer === 0) e.alive = false;
      continue;
    }
    
    // Movement based on type
    if (e.type === 0) {
      // Phishing Email - patrol with edge and obstacle detection
      const nextX = e.x + e.vx;
      const checkX = e.vx > 0 ? nextX + 14 : nextX + 2;
      // Reverse if hitting boundary, edge, or obstacle
      if (nextX <= e.minX || nextX >= e.maxX || 
          !hasGroundAt(checkX, e.y + 18) || 
          enemyHitsObstacle(nextX, e.y, 16, 16)) {
        e.vx *= -1;
      } else {
        e.x = nextX;
      }
} else if (e.type === 1) {
      // Data Breach Worm - simple patrol (same as type 0)
      const nextX = e.x + e.vx;
      const checkX = e.vx > 0 ? nextX + 14 : nextX + 2;
      if (nextX <= e.minX || nextX >= e.maxX || 
          !hasGroundAt(checkX, e.y + 18) ||
          enemyHitsObstacle(nextX, e.y, 16, 16)) {
        e.vx *= -1;
      } else {
        e.x = nextX;
      }
    } else if (e.type === 2) {
      // Hacker - chase AI
      const dx = player.x - e.x;
      const dist = Math.abs(dx);
      
      if (e.state === 'patrol') {
        const nextX = e.x + e.vx * 0.25;
        const checkX = e.vx > 0 ? nextX + 14 : nextX + 2;
        if (nextX <= e.minX || nextX >= e.maxX || 
            !hasGroundAt(checkX, e.y + 18) ||
            enemyHitsObstacle(nextX, e.y, 16, 16)) {
          e.vx *= -1;
        } else {
          e.x = nextX;
        }
        if (dist < 80 && Math.abs(player.y - e.y) < 48) {
          e.state = 'alert';
          e.alertTimer = 45;
        }
      } else if (e.state === 'alert') {
        e.alertTimer--;
        if (e.alertTimer <= 0) e.state = 'chase';
      } else if (e.state === 'chase') {
        // Hackers chase but stop at edges and obstacles
        // Dead zone: only change direction if player is significantly to one side
        if (dist > 8) {
          e.vx = dx > 0 ? 0.4 : -0.4;
        }
        const nextX = e.x + e.vx;
        const checkX = e.vx > 0 ? nextX + 14 : nextX + 2;
        // Only move if there's ground ahead, within bounds, and no obstacle
        if (nextX > e.minX && nextX < e.maxX && 
            hasGroundAt(checkX, e.y + 18) &&
            !enemyHitsObstacle(nextX, e.y, 16, 16)) {
          e.x = nextX;
        }
        // Ground tethering - maintain Y position (no flying)
        e.y = e.baseY;
        if (dist > 140) e.state = 'patrol';
      }
    } else if (e.type === 3) {
      // Credential Stealer - fly up, drop behind player, hesitate, approach
      const dx = player.x - e.x;
      const dist = Math.abs(dx);
      if (e.state === 'patrol') {
        const nextX = e.x + e.vx * 0.25;
        const checkX = e.vx > 0 ? nextX + 14 : nextX + 2;
        if (nextX <= e.minX || nextX >= e.maxX || 
            !hasGroundAt(checkX, e.y + 18) ||
            enemyHitsObstacle(nextX, e.y, 16, 16)) {
          e.vx *= -1;
        } else {
          e.x = nextX;
        }
        // Trigger when player gets close
        if (dist < 70 && Math.abs(player.y - e.y) < 40) {
          e.state = 'flyup';
          e.flyTimer = 25;
          e.targetX = player.x + (dx > 0 ? -40 : 40); // Behind player
        }
      } else if (e.state === 'flyup') {
        // Rise up
        e.y -= 1.2;
        e.flyTimer--;
        if (e.flyTimer <= 0) {
          e.state = 'flyover';
          e.flyTimer = 30;
        }
      } else if (e.state === 'flyover') {
        // Move toward position behind player
        const toTarget = e.targetX - e.x;
        e.x += Math.sign(toTarget) * Math.min(Math.abs(toTarget), 1);
        e.flyTimer--;
        if (e.flyTimer <= 0 || Math.abs(toTarget) < 5) {
          e.state = 'drop';
          e.flyTimer = 20;
        }
      } else if (e.state === 'drop') {
        // Drop down
        e.y += 1.5;
        if (e.y >= e.baseY) {
          e.y = e.baseY;
          e.state = 'hesitate';
          e.hesitateTimer = 50;
        }
      } else if (e.state === 'hesitate') {
        // Pause menacingly
        e.hesitateTimer--;
        if (e.hesitateTimer <= 0) {
          e.state = 'approach';
          e.approachTimer = 60;
        }
      } else if (e.state === 'approach') {
        // Slowly move toward player but respect edges and obstacles
        const adx = player.x - e.x;
        const moveDir = Math.sign(adx);
        const nextX = e.x + moveDir * 0.35;
        const checkX = moveDir > 0 ? nextX + 14 : nextX + 2;
        if (nextX > e.minX && nextX < e.maxX && 
            hasGroundAt(checkX, e.y + 18) &&
            !enemyHitsObstacle(nextX, e.y, 16, 16)) {
          e.x = nextX;
        }
        e.approachTimer--;
        if (e.approachTimer <= 0) {
          e.state = 'cooldown';
          e.cooldownTimer = 50;
        }
      } else if (e.state === 'cooldown') {
        e.cooldownTimer--;
        if (e.cooldownTimer <= 0) e.state = 'patrol';
      }
    } else if (e.type === 4) {
      // Malicious Attachment - slow menacing bounce with edge and obstacle detection
      const nextX = e.x + e.vx * 0.5;
      const checkX = e.vx > 0 ? nextX + 14 : nextX + 2;
      if (nextX <= e.minX || nextX >= e.maxX || 
          !hasGroundAt(checkX, e.baseY + 18) ||
          enemyHitsObstacle(nextX, e.baseY, 16, 16)) {
        e.vx *= -1;
      } else {
        e.x = nextX;
      }
      e.bounceTimer = (e.bounceTimer || 0) + 1;
      e.y = e.baseY + Math.abs(Math.sin(e.bounceTimer * 0.05)) * -24;
    } else if (e.type === 5) {
      // Rogue Access Point - smooth floating patrol (no ground needed - it hovers!)
      e.floatTimer = (e.floatTimer || 0) + 1;
      e.baseY = e.baseY || e.y;
      
      // Simple boundary patrol - no ground check needed for floating enemy
      const nextX = e.x + e.vx * 0.25;
      if (nextX <= e.minX || nextX >= e.maxX) {
        e.vx *= -1;
      } else {
        e.x = nextX;
      }
      
      // Gentle vertical bob (reduced amplitude)
      e.y = e.baseY + Math.sin(e.floatTimer * 0.025) * 6;
      e.dangerRadius = 0;
    } else if (e.type === 6) {
      // Packet Sniffer - follows player but respects edges and obstacles
      e.pathHistory = e.pathHistory || [];
      e.pathDelay = e.pathDelay || 60;
      if (frame % 3 === 0) {
        e.pathHistory.push({ x: player.x, y: player.y });
        if (e.pathHistory.length > e.pathDelay) {
          const target = e.pathHistory.shift();
          const tdx = target.x - e.x;
          const moveDir = Math.sign(tdx);
          const moveAmt = Math.min(Math.abs(tdx), 0.8);
          const nextX = e.x + moveDir * moveAmt;
          const checkX = moveDir > 0 ? nextX + 14 : nextX + 2;
          // Only move if there's ground ahead and no obstacle
          if (nextX > e.minX && nextX < e.maxX && 
              hasGroundAt(checkX, e.baseY + 18) &&
              !enemyHitsObstacle(nextX, e.y, 16, 16)) {
            e.x = nextX;
          }
          // Stay grounded at baseY
          e.y = e.baseY;
        }
      }
    } else if (e.type === 7) {
      // Ransomware - chases player but respects edges and obstacles
      const dx = player.x - e.x;
      const dist = Math.abs(dx);
      if (dist < 120) {
        e.vx = dx > 0 ? 0.6 : -0.6;
      } else {
        e.vx *= 0.95;
      }
      const nextX = e.x + e.vx;
      const checkX = e.vx > 0 ? nextX + 14 : nextX + 2;
      // Only move if there's ground ahead and no obstacle
      if (nextX > e.minX && nextX < e.maxX && 
          hasGroundAt(checkX, e.y + 18) &&
          !enemyHitsObstacle(nextX, e.y, 16, 16)) {
        e.x = nextX;
      } else {
        e.vx = 0;  // Stop at edge/obstacle
      }
    } else if (e.type === 8) {
      // Data Exfiltrator - patrols and pulls player toward it, respects obstacles
      const nextX = e.x + e.vx * 0.2;
      const checkX = e.vx > 0 ? nextX + 14 : nextX + 2;
      if (nextX <= e.minX || nextX >= e.maxX || 
          !hasGroundAt(checkX, e.y + 18) ||
          enemyHitsObstacle(nextX, e.y, 16, 16)) {
        e.vx *= -1;
      } else {
        e.x = nextX;
      }
      const dx = player.x - e.x;
      const dist = Math.abs(dx);
      if (dist < 80 && player.invincible <= 0) {
        player.x -= Math.sign(dx) * 0.3;
      }
    }
    
    // Player collision
      // Wider hitbox for easier stomping (24px wide, centered on 16px sprite)
      const eHitW = 28;
      const eHitH = 16;
      const eHitX = e.x - 6;  // Center the wider hitbox
      
      if (rectOverlap(player.x, player.y, pw, ph, eHitX, e.y, eHitW, eHitH)) {
        // More forgiving stomp detection:
        // - Player must be falling (vy > 0)
        // - Player's feet must be in the top 60% of enemy (was top 10px of 16px)
        // - Player's center must be roughly over the enemy
        const playerFeetY = player.y + ph;
        const enemyMidY = e.y + eHitH * 0.75;  // Top 60% is stompable
        const playerCenterX = player.x + pw / 2;
        const enemyCenterX = eHitX + eHitW / 2;
        const horizontalOverlap = Math.abs(playerCenterX - enemyCenterX) < (pw / 2 + eHitW / 2 - 2);
        
        if (player.vy > 0 && playerFeetY < enemyMidY) {
          // All enemies die on stomp (no shell mode)
          e.stompTimer = 15;
          
          player.vy = input.a ? -6 : -4;
          hitstop = 4;
          screenShake = 3;
          SFX.stomp();
          spawnParticles(e.x + 8, e.y + 8, '#ff8844', 8);
          floatingTexts.push({ x: e.x, y: e.y - 8, text: 'BLOCKED!', timer: 40, vy: -1 });
        } else if (player.invincible <= 0) {
          die();
        }
      }
  }
}

function updatePowerups() {
  for (const pu of powerups) {
    pu.timer++;
  }
}

function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4 - 2,
      life: 20 + Math.random() * 15,
      color, gravity: false, size: 3
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    if (p.gravity) p.vy += 0.2;
    else p.vy += 0.1;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }
  
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const ft = floatingTexts[i];
    ft.y += ft.vy;
    ft.timer--;
    if (ft.timer <= 0) floatingTexts.splice(i, 1);
  }
}

function updateCamera() {
  // QA FIX: Dead-zone camera - tightened for better control
  // Player stays closer to center, camera follows earlier
  const screenCenter = W / 2;  // 128px
  const deadZoneHalf = W / 8;  // 32px - player can move freely within center 25% only
  const hardEdge = W * 0.40;   // 90px - player never gets closer than 40% from edge
  
  // Player position relative to camera
  const playerScreenX = player.x - camera.x;
  
  // Calculate where camera SHOULD be to keep player in dead zone
  let targetX = camera.targetX;
  
  // Player pushing right edge of dead zone
  if (playerScreenX > screenCenter + deadZoneHalf) {
    targetX = player.x - (screenCenter + deadZoneHalf);
  }
  // Player pushing left edge of dead zone
  else if (playerScreenX < screenCenter - deadZoneHalf) {
    targetX = player.x - (screenCenter - deadZoneHalf);
  }
  
  // Hard clamp: Player must NEVER be within 25% of screen edge
  // This overrides dead zone if player is moving fast
  const playerMinScreen = hardEdge;
  const playerMaxScreen = W - hardEdge;
  if (playerScreenX < playerMinScreen) {
    targetX = player.x - playerMinScreen;
  } else if (playerScreenX > playerMaxScreen) {
    targetX = player.x - playerMaxScreen;
  }
  
  camera.targetX = targetX;
  
  // Smooth lerp - 0.1 for tighter following (was 0.025)
  camera.x += (camera.targetX - camera.x) * 0.25;
  
  // World bounds
  if (camera.x < 0) camera.x = 0;
  if (camera.x > level.width - W) camera.x = level.width - W;
}

function die() {
  if (player.big) {
    player.big = false;
    player.invincible = 180;
    SFX.hurt();
    screenShake = 8;
    floatingTexts.push({ x: player.x, y: player.y - 16, text: 'SHIELD DOWN!', timer: 50, vy: -1 });
    return;
  }
  
  lives--;
  SFX.hurt();
  screenShake = 12;
  
  if (lives <= 0) {
    state = 'lose';
    playMusic('lose');
  } else {
    if (checkpointReached >= 0 && level.checkpoints && level.checkpoints[checkpointReached]) {
      const cp = level.checkpoints[checkpointReached];
      player.x = cp[0];
      player.y = cp[1];
      camera.x = Math.max(0, cp[0] - 128);
      camera.targetX = camera.x;
      // REMOVED: Token preservation fix - never reduce collected tokens on death
    } else {
      player.x = level.playerStart[0];
      player.y = level.playerStart[1];
      camera.x = 0;
      camera.targetX = 0;
    }
    player.vx = 0;
    player.vy = 0;
    player.invincible = 180;
  }
}

// ============================================================
// DRAWING - CDW LOGO
// ============================================================
function drawCDWLogo(x, y, scale = 1) {
  ctx.save();
  ctx.translate(x, y);
  // Scale from 200x107 original to game size (0.25 = 50px wide)
  ctx.scale(scale * 0.25, scale * 0.25);
  
  // Official CDW Red: #C50306
  ctx.fillStyle = "#C50306";
  
  // Pixel-perfect spans from image analysis: [y, x_start, x_end]
  const spans = [
    [2,144,163],[3,136,169],[4,128,174],[5,124,176],[6,119,139],[6,144,180],
    [7,117,126],[7,152,182],[8,112,119],[8,158,184],[9,109,115],[9,161,185],
    [10,105,108],[10,164,187],[11,103,106],[11,165,188],[12,100,102],[12,168,189],
    [13,99,99],[13,169,190],[14,171,191],[15,172,191],[16,173,193],[17,174,193],
    [18,174,193],[19,175,194],[20,176,194],[21,176,195],[22,177,195],[23,177,195],
    [24,21,35],[24,55,75],[24,93,104],[24,115,127],[24,138,150],[24,177,195],
    [25,19,37],[25,54,79],[25,92,104],[25,114,127],[25,137,150],[25,178,195],
    [26,16,39],[26,54,81],[26,92,104],[26,114,128],[26,137,150],[26,178,195],
    [27,15,40],[27,53,82],[27,92,104],[27,113,128],[27,137,149],[27,178,195],
    [28,14,41],[28,53,83],[28,92,104],[28,113,128],[28,136,149],[28,178,195],
    [29,13,42],[29,53,84],[29,92,104],[29,112,128],[29,136,148],[29,178,195],
    [30,12,43],[30,53,85],[30,92,104],[30,112,128],[30,136,148],[30,178,195],
    [31,11,43],[31,52,85],[31,92,104],[31,112,128],[31,135,147],[31,178,195],
    [32,10,44],[32,52,86],[32,92,104],[32,111,128],[32,135,147],[32,178,195],
    [33,9,44],[33,52,66],[33,69,87],[33,92,104],[33,111,128],[33,134,147],[33,178,195],
    [34,9,24],[34,30,45],[34,52,65],[34,74,87],[34,92,104],[34,111,128],[34,134,146],[34,178,194],
    [35,8,23],[35,31,45],[35,52,65],[35,74,87],[35,92,104],[35,110,128],[35,134,146],[35,178,194],
    [36,7,22],[36,32,45],[36,51,65],[36,74,87],[36,92,104],[36,110,128],[36,133,145],[36,178,194],
    [37,7,21],[37,32,45],[37,51,65],[37,74,88],[37,92,104],[37,109,127],[37,133,145],[37,178,193],
    [38,6,21],[38,32,45],[38,51,64],[38,75,88],[38,92,104],[38,109,127],[38,133,145],[38,177,193],
    [39,6,20],[39,32,45],[39,51,64],[39,75,88],[39,92,104],[39,109,127],[39,132,144],[39,177,193],
    [40,6,20],[40,33,44],[40,50,64],[40,75,88],[40,92,104],[40,108,127],[40,132,144],[40,177,192],
    [41,6,20],[41,50,64],[41,75,88],[41,92,104],[41,108,127],[41,132,143],[41,176,192],
    [42,5,19],[42,50,63],[42,74,88],[42,92,104],[42,108,127],[42,131,143],[42,176,191],
    [43,5,19],[43,50,63],[43,74,88],[43,92,104],[43,107,116],[43,118,127],[43,131,142],[43,176,191],
    [44,5,19],[44,50,63],[44,74,87],[44,92,104],[44,107,115],[44,118,127],[44,130,142],[44,175,190],
    [45,5,19],[45,50,63],[45,74,87],[45,92,104],[45,106,115],[45,118,127],[45,130,141],[45,174,189],
    [46,5,19],[46,49,63],[46,74,87],[46,92,104],[46,106,115],[46,118,127],[46,130,141],[46,174,189],
    [47,5,19],[47,49,63],[47,74,87],[47,92,114],[47,119,128],[47,130,141],[47,174,188],
    [48,5,19],[48,49,62],[48,74,87],[48,92,114],[48,119,140],[48,173,188],
    [49,5,19],[49,32,33],[49,38,39],[49,48,62],[49,73,86],[49,92,113],[49,119,140],[49,172,187],
    [50,5,19],[50,30,43],[50,48,62],[50,72,86],[50,92,113],[50,119,139],[50,171,186],
    [51,5,19],[51,30,43],[51,48,61],[51,72,85],[51,92,113],[51,119,139],[51,171,185],
    [52,5,19],[52,29,43],[52,48,61],[52,71,85],[52,92,112],[52,119,138],[52,170,185],
    [53,5,19],[53,28,42],[53,48,61],[53,71,85],[53,92,112],[53,119,138],[53,169,184],
    [54,5,20],[54,28,42],[54,48,61],[54,70,84],[54,92,111],[54,119,137],[54,168,183],
    [55,6,21],[55,27,41],[55,47,61],[55,67,83],[55,92,111],[55,119,137],[55,168,182],
    [56,6,41],[56,47,83],[56,92,111],[56,119,137],[56,167,181],
    [57,6,40],[57,47,82],[57,92,110],[57,119,136],[57,166,180],
    [58,7,39],[58,47,81],[58,92,110],[58,119,136],[58,165,179],
    [59,8,39],[59,46,80],[59,92,109],[59,119,135],[59,164,178],
    [60,8,38],[60,46,79],[60,92,109],[60,119,135],[60,163,177],
    [61,9,36],[61,46,77],[61,92,108],[61,118,134],[61,162,176],
    [62,10,34],[62,46,76],[62,92,108],[62,118,134],[62,160,175],
    [63,12,33],[63,46,74],[63,92,108],[63,119,134],[63,160,174],
    [64,15,30],[64,46,69],[64,93,106],[64,119,133],[64,158,172],
    [65,18,27],[65,157,171],[66,155,170],[67,154,169],[68,153,167],
    [69,151,166],[70,150,165],[71,148,163],[72,147,162],[73,146,160],
    [74,143,159],[75,142,157],[76,24,24],[76,140,155],[77,24,24],[77,138,154],
    [78,136,152],[79,24,24],[79,135,150],[80,24,25],[80,132,148],
    [81,24,25],[81,131,147],[82,24,25],[82,128,144],[83,24,25],[83,126,143],
    [84,24,26],[84,123,140],[85,25,26],[85,122,139],[86,25,27],[86,119,137],
    [87,25,27],[87,116,135],[88,26,28],[88,113,133],[89,26,29],[89,111,130],
    [90,27,30],[90,107,127],[91,28,32],[91,104,125],[92,28,34],[92,101,122],
    [93,29,36],[93,98,120],[94,31,38],[94,93,117],[95,32,41],[95,89,114],
    [96,33,46],[96,83,111],[97,35,51],[97,76,107],[98,37,103],
    [99,39,100],[100,43,95],[101,46,90],[102,51,83],[103,57,74],
  ];
  
  // Center the logo (original is 200 wide, center at ~100)
  ctx.translate(-100, -53);
  
  // Draw each span as a filled rectangle
  for (const [y, x1, x2] of spans) {
    ctx.fillRect(x1, y, x2 - x1 + 1, 1);
  }
  
  ctx.restore();
}

// ============================================================
// DRAWING - CISCO LOGO  
// ============================================================
function drawCiscoLogo(x, y, scale = 1) {
  ctx.save();
  ctx.translate(x, y);
  // Scale from 300x300 original to game size (0.18 = ~54px wide)
  ctx.scale(scale * 0.18, scale * 0.18);
  
  // Official Cisco Blue from image: #0D9AD0
  ctx.fillStyle = "#0D9AD0";
  
  // Pixel-perfect spans from image analysis: [y, x_start, x_end]
  const spans = [
    [93,96,99],[93,200,204],[94,94,100],[94,199,205],[95,94,101],[95,198,205],
    [96,93,101],[96,198,206],[97,93,101],[97,198,206],[98,93,101],[98,198,206],
    [99,93,101],[99,198,206],[100,93,101],[100,198,206],[101,93,101],[101,198,206],
    [102,93,101],[102,198,206],[103,93,101],[103,198,206],[104,93,101],[104,198,206],
    [105,93,101],[105,198,206],[106,93,101],[106,198,206],[107,93,101],[107,198,206],
    [108,93,101],[108,198,206],[109,93,101],[109,198,206],[110,93,101],[110,198,206],
    [111,69,73],[111,93,101],[111,122,125],[111,174,177],[111,198,206],[111,226,230],
    [112,68,74],[112,93,101],[112,120,127],[112,172,179],[112,198,206],[112,225,231],
    [113,67,75],[113,93,101],[113,120,127],[113,172,179],[113,198,206],[113,224,232],
    [114,67,75],[114,93,101],[114,119,127],[114,172,180],[114,198,206],[114,224,232],
    [115,67,75],[115,93,101],[115,119,127],[115,172,180],[115,198,206],[115,224,232],
    [116,67,75],[116,93,101],[116,119,127],[116,172,180],[116,198,206],[116,224,232],
    [117,67,75],[117,93,101],[117,119,127],[117,172,180],[117,198,206],[117,224,232],
    [118,67,75],[118,93,101],[118,119,127],[118,172,180],[118,198,206],[118,224,232],
    [119,67,75],[119,93,101],[119,119,127],[119,172,180],[119,198,206],[119,224,232],
    [120,67,75],[120,93,101],[120,119,127],[120,172,180],[120,198,206],[120,224,232],
    [121,67,75],[121,93,101],[121,119,127],[121,172,180],[121,198,206],[121,224,232],
    [122,67,75],[122,93,101],[122,119,127],[122,172,180],[122,198,206],[122,224,232],
    [123,67,75],[123,93,101],[123,119,127],[123,172,180],[123,198,206],[123,224,232],
    [124,43,47],[124,67,75],[124,93,101],[124,119,127],[124,148,151],[124,172,180],[124,198,206],[124,224,232],[124,253,256],
    [125,42,48],[125,67,75],[125,93,101],[125,119,127],[125,147,152],[125,172,180],[125,198,206],[125,224,232],[125,251,257],
    [126,41,48],[126,67,75],[126,93,101],[126,119,127],[126,146,153],[126,172,180],[126,198,206],[126,224,232],[126,251,258],
    [127,41,49],[127,67,75],[127,93,101],[127,119,127],[127,146,153],[127,172,180],[127,198,206],[127,224,232],[127,250,258],
    [128,41,49],[128,67,75],[128,93,101],[128,119,127],[128,146,153],[128,172,180],[128,198,206],[128,224,232],[128,250,258],
    [129,41,49],[129,67,75],[129,93,101],[129,119,127],[129,146,153],[129,172,180],[129,198,206],[129,224,232],[129,250,258],
    [130,41,49],[130,67,75],[130,93,101],[130,119,127],[130,146,153],[130,172,180],[130,198,206],[130,224,232],[130,250,258],
    [131,41,49],[131,67,75],[131,93,101],[131,119,127],[131,146,153],[131,172,180],[131,198,206],[131,224,232],[131,250,258],
    [132,41,49],[132,67,75],[132,93,101],[132,119,127],[132,146,153],[132,172,180],[132,198,206],[132,224,232],[132,250,258],
    [133,41,49],[133,67,75],[133,93,101],[133,119,127],[133,146,153],[133,172,180],[133,198,206],[133,224,232],[133,250,258],
    [134,41,49],[134,67,75],[134,93,101],[134,119,127],[134,146,153],[134,172,180],[134,198,206],[134,224,232],[134,250,258],
    [135,41,49],[135,67,75],[135,93,101],[135,119,127],[135,146,153],[135,172,180],[135,198,206],[135,224,232],[135,250,258],
    [136,41,49],[136,67,75],[136,93,101],[136,119,127],[136,146,153],[136,172,180],[136,198,206],[136,224,232],[136,250,258],
    [137,41,49],[137,67,75],[137,93,101],[137,119,127],[137,146,153],[137,172,180],[137,198,206],[137,224,232],[137,250,258],
    [138,41,49],[138,67,75],[138,93,101],[138,119,127],[138,146,153],[138,172,180],[138,198,206],[138,224,232],[138,250,258],
    [139,41,48],[139,67,75],[139,93,101],[139,120,127],[139,146,153],[139,172,179],[139,198,206],[139,224,232],[139,250,258],
    [140,42,48],[140,68,74],[140,93,101],[140,120,127],[140,146,153],[140,173,179],[140,198,206],[140,225,231],[140,251,257],
    [141,43,47],[141,69,73],[141,93,101],[141,121,125],[141,148,151],[141,174,178],[141,198,206],[141,226,230],[141,252,256],
    [142,93,101],[142,198,206],[142,228,228],
    [143,93,101],[143,198,206],[144,93,101],[144,198,206],[145,93,101],[145,198,206],
    [146,93,101],[146,198,206],[147,93,101],[147,198,206],[148,93,101],[148,198,205],
    [149,94,101],[149,198,205],[150,95,100],[150,199,204],[151,96,99],[151,200,203],
    [169,75,86],[169,104,110],[169,134,145],[169,175,186],[169,214,224],
    [170,72,88],[170,103,111],[170,131,147],[170,172,188],[170,211,227],
    [171,70,88],[171,103,111],[171,129,147],[171,170,188],[171,209,229],
    [172,68,88],[172,103,111],[172,128,147],[172,168,188],[172,208,231],
    [173,67,88],[173,103,111],[173,127,147],[173,167,188],[173,206,232],
    [174,66,88],[174,103,111],[174,127,147],[174,166,188],[174,205,233],
    [175,65,88],[175,103,111],[175,126,147],[175,165,188],[175,204,234],
    [176,64,88],[176,103,111],[176,126,137],[176,145,147],[176,164,188],[176,203,235],
    [177,63,79],[177,81,88],[177,103,111],[177,126,135],[177,164,188],[177,203,235],
    [178,63,75],[178,103,111],[178,125,134],[178,163,175],[178,202,214],[178,224,236],
    [179,63,74],[179,103,111],[179,125,134],[179,163,174],[179,202,213],[179,226,236],
    [180,62,72],[180,103,111],[180,125,134],[180,162,173],[180,201,211],[180,227,237],
    [181,62,72],[181,103,111],[181,125,135],[181,162,172],[181,201,211],[181,228,237],
    [182,61,71],[182,103,111],[182,126,136],[182,162,171],[182,201,210],[182,228,238],
    [183,61,70],[183,103,111],[183,126,138],[183,161,171],[183,200,209],[183,229,238],
    [184,61,70],[184,103,111],[184,126,141],[184,161,170],[184,200,209],[184,229,238],
    [185,61,70],[185,103,111],[185,127,144],[185,161,170],[185,200,209],[185,230,238],
    [186,61,69],[186,103,111],[186,127,145],[186,161,170],[186,200,209],[186,230,238],
    [187,61,69],[187,103,111],[187,128,146],[187,161,170],[187,200,208],[187,230,238],
    [188,61,69],[188,103,111],[188,130,147],[188,161,170],[188,200,208],[188,230,238],
    [189,61,69],[189,103,111],[189,132,148],[189,161,170],[189,200,208],[189,230,238],
    [190,61,70],[190,103,111],[190,134,149],[190,161,170],[190,200,209],[190,230,238],
    [191,61,70],[191,103,111],[191,136,149],[191,161,170],[191,200,209],[191,229,238],
    [192,61,70],[192,103,111],[192,139,149],[192,161,171],[192,200,209],[192,229,238],
    [193,61,71],[193,103,111],[193,141,150],[193,161,171],[193,201,210],[193,228,238],
    [194,62,71],[194,103,111],[194,141,150],[194,162,172],[194,201,211],[194,228,237],
    [195,62,72],[195,103,111],[195,141,150],[195,162,173],[195,201,211],[195,227,237],
    [196,63,74],[196,103,111],[196,141,150],[196,163,174],[196,202,213],[196,225,236],
    [197,63,76],[197,87,88],[197,103,111],[197,141,149],[197,163,175],[197,187,187],[197,202,214],[197,224,236],
    [198,64,88],[198,103,111],[198,140,149],[198,164,188],[198,203,235],
    [199,64,88],[199,103,111],[199,125,131],[199,137,149],[199,164,188],[199,204,235],
    [200,65,88],[200,103,111],[200,125,148],[200,165,188],[200,205,234],
    [201,66,88],[201,103,111],[201,125,148],[201,166,188],[201,205,232],
    [202,67,88],[202,103,111],[202,125,147],[202,167,188],[202,206,232],
    [203,68,88],[203,103,111],[203,125,146],[203,168,188],[203,208,231],
    [204,70,88],[204,103,111],[204,125,145],[204,170,188],[204,209,229],
    [205,72,88],[205,103,111],[205,126,143],[205,172,188],[205,211,227],
    [206,75,87],[206,104,110],[206,126,140],[206,175,186],[206,214,224],
  ];
  
  // Center the logo (original bounds: cols 41-258, rows 93-206)
  // Center x = (41+258)/2 = 149.5, center y = (93+206)/2 = 149.5
  ctx.translate(-150, -150);
  
  // Draw each span as a filled rectangle
  for (const [y, x1, x2] of spans) {
    ctx.fillRect(x1, y, x2 - x1 + 1, 1);
  }
  
  ctx.restore();
}

// ============================================================
// DRAWING - DUO MFA TOKEN
// ============================================================
function drawDuoToken(x, y, anim) {
  const bob = Math.sin(anim) * 2;
  const shine = Math.sin(anim * 2) * 0.3 + 0.7;
  
  // Glow
  ctx.fillStyle = `rgba(116, 191, 75, ${shine * 0.3})`;
  ctx.beginPath();
  ctx.arc(x + 7, y + 7 + bob, 10, 0, Math.PI * 2);
  ctx.fill();
  
  // Shield shape
  ctx.fillStyle = BRAND.duoGreen;
  ctx.beginPath();
  ctx.moveTo(x + 7, y + bob);
  ctx.lineTo(x + 14, y + 4 + bob);
  ctx.lineTo(x + 14, y + 10 + bob);
  ctx.lineTo(x + 7, y + 14 + bob);
  ctx.lineTo(x, y + 10 + bob);
  ctx.lineTo(x, y + 4 + bob);
  ctx.closePath();
  ctx.fill();
  
  // Checkmark
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x + 3, y + 7 + bob);
  ctx.lineTo(x + 6, y + 10 + bob);
  ctx.lineTo(x + 11, y + 4 + bob);
  ctx.stroke();
}

// ============================================================
// DRAWING - MALICIOUS ATTACHMENT (Evil Clippy)
// ============================================================
function drawPhishingEmail(x, y, anim, squash = 1) {
  ctx.save();
  ctx.translate(x + 8, y + 16);
  ctx.scale(1, squash);
  ctx.translate(-8, -16);
  
  var bounce = Math.sin(anim * 0.12) * 1;
  var lean = Math.sin(anim * 0.08) * 0.06;
  ctx.rotate(lean);
  ctx.translate(0, bounce - 6);
  
  // Shadow
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.beginPath();
  ctx.ellipse(8, 26 - bounce, 5, 2, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // === PAPERCLIP WIRE ===
  ctx.strokeStyle = "#888899";
  ctx.lineWidth = 4;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  
  ctx.beginPath();
  ctx.moveTo(5, 24);
  ctx.lineTo(5, 8);
  ctx.quadraticCurveTo(5, 2, 8, 2);
  ctx.quadraticCurveTo(11, 2, 11, 8);
  ctx.lineTo(11, 16);
  ctx.quadraticCurveTo(11, 19, 8, 19);
  ctx.lineTo(7, 19);
  ctx.quadraticCurveTo(5, 19, 5, 16);
  ctx.stroke();
  
  // Chrome highlight
  ctx.strokeStyle = "#bbbbcc";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(4, 23);
  ctx.lineTo(4, 8);
  ctx.quadraticCurveTo(4, 3, 8, 3);
  ctx.stroke();
  
  // Chrome shadow
  ctx.strokeStyle = "#666677";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(12, 8);
  ctx.lineTo(12, 15);
  ctx.stroke();
  
  // === EYES ===
  var blinkFrame = Math.floor(anim) % 120;
  var isBlinking = blinkFrame > 115;
  var lookX = Math.sin(anim * 0.07) * 1.2;
  var lookY = Math.cos(anim * 0.05) * 0.5;
  
  ctx.fillStyle = "#ffffff";
  ctx.strokeStyle = "#444";
  ctx.lineWidth = 0.8;
  
  ctx.beginPath();
  ctx.ellipse(6, 8, 2.5, isBlinking ? 0.5 : 2.8, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  
  ctx.beginPath();
  ctx.ellipse(10, 8, 2.5, isBlinking ? 0.5 : 2.8, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  
  if (!isBlinking) {
    var pupilGlow = Math.sin(anim * 0.2) * 0.3 + 0.7;
    
    ctx.fillStyle = "rgba(255,0,0," + (pupilGlow * 0.5) + ")";
    ctx.beginPath();
    ctx.arc(6 + lookX, 8 + lookY, 2.5, 0, Math.PI * 2);
    ctx.arc(10 + lookX, 8 + lookY, 2.5, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#cc0000";
    ctx.beginPath();
    ctx.arc(6 + lookX, 8 + lookY, 1.6, 0, Math.PI * 2);
    ctx.arc(10 + lookX, 8 + lookY, 1.6, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = "#440000";
    ctx.fillRect(5.3 + lookX, 7 + lookY, 1.4, 2.5);
    ctx.fillRect(9.3 + lookX, 7 + lookY, 1.4, 2.5);
    
    ctx.fillStyle = "#ff6666";
    ctx.beginPath();
    ctx.arc(5 + lookX, 7 + lookY, 0.6, 0, Math.PI * 2);
    ctx.arc(9 + lookX, 7 + lookY, 0.6, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // === ANGRY EYEBROWS (V-shaped, very prominent) ===
  ctx.strokeStyle = "#660000";
  ctx.lineWidth = 3;
  ctx.lineCap = "round";
  // Left brow - steep V angle
  ctx.beginPath();
  ctx.moveTo(2, 4);
  ctx.lineTo(7, 6);
  ctx.stroke();
  // Right brow - steep V angle
  ctx.beginPath();
  ctx.moveTo(14, 4);
  ctx.lineTo(9, 6);
  ctx.stroke();
  
  // === EVIL SNEER ===
  // Angry downturned mouth
  ctx.fillStyle = "#220000";
  ctx.beginPath();
  ctx.moveTo(4, 12);
  ctx.quadraticCurveTo(8, 15, 12, 12);
  ctx.lineTo(11, 14);
  ctx.quadraticCurveTo(8, 11, 5, 14);
  ctx.closePath();
  ctx.fill();
  
  // Jagged fangs
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.moveTo(5, 12.5);
  ctx.lineTo(6, 15);
  ctx.lineTo(7, 12.5);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(7.5, 12.5);
  ctx.lineTo(8.5, 15.5);
  ctx.lineTo(9.5, 12.5);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(10, 12.5);
  ctx.lineTo(11, 15);
  ctx.lineTo(12, 12.5);
  ctx.fill();
  
  // Mouth outline
  ctx.strokeStyle = "#550000";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(4, 12);
  ctx.quadraticCurveTo(8, 15, 12, 12);
  ctx.stroke();
  
  // === ENVELOPE ===
  ctx.save();
  ctx.translate(-5, 16);
  ctx.rotate(Math.sin(anim * 0.1) * 0.15 - 0.1);
  
  ctx.fillStyle = "#fff8e8";
  ctx.fillRect(0, 0, 10, 7);
  ctx.strokeStyle = "#ccbbaa";
  ctx.lineWidth = 0.5;
  ctx.strokeRect(0, 0, 10, 7);
  
  ctx.fillStyle = "#f0e8d8";
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(5, 4);
  ctx.lineTo(10, 0);
  ctx.closePath();
  ctx.fill();
  
  ctx.fillStyle = "#dd0000";
  ctx.beginPath();
  ctx.arc(5, 3.5, 2.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#ffff00";
  ctx.font = "bold 4px sans-serif";
  ctx.fillText("!", 3.8, 5);
  
  ctx.restore();
  
  if (Math.floor(anim * 0.25) % 8 === 0) {
    ctx.fillStyle = "rgba(255,0,0,0.35)";
    ctx.fillRect(3, (anim * 2) % 20 + 2, 10, 1);
  }
  
  var auraPulse = Math.sin(anim * 0.1) * 0.12 + 0.18;
  ctx.strokeStyle = "rgba(255,0,0," + auraPulse + ")";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.ellipse(8, 14, 11, 14, 0, 0, Math.PI * 2);
  ctx.stroke();
  
  ctx.restore();
}


// ============================================================
// DRAWING - CLICKBAIT (Phishing Fish)
// ============================================================
function drawDataBreachWorm(x, y, anim, squash = 1, flipped = false) {
  ctx.save();
  ctx.translate(x + 8, y + 16);
  ctx.scale(1, squash);
  ctx.translate(-8, -16);
  
  // Scale to fit 16x16 hitbox
  ctx.translate(8, 8);
  ctx.scale(0.90, 0.90);
  ctx.translate(-8, -8);
  
    var bounce = Math.sin(anim * 0.15) * 2;
    var wiggle = Math.sin(anim * 0.2) * 0.1;
    ctx.rotate(wiggle);
    ctx.translate(0, bounce);
    
    // Shadow
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.beginPath();
    ctx.ellipse(8, 18 - bounce, 7, 2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // === FISHING LINE (dangles from above) ===
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 1;
    var lineWave = Math.sin(anim * 0.1) * 2;
    ctx.beginPath();
    ctx.moveTo(8, -15);
    ctx.quadraticCurveTo(8 + lineWave, -8, 8, -2);
    ctx.stroke();
    
    // Hook
    ctx.strokeStyle = "#888";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(8, -2);
    ctx.lineTo(8, 1);
    ctx.arc(6, 1, 2, 0, Math.PI);
    ctx.stroke();
    
    // Lure bobber on line
    ctx.fillStyle = "#ff0000";
    ctx.beginPath();
    ctx.arc(8, -10, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(8, -10, 3, Math.PI * 0.5, Math.PI * 1.5);
    ctx.fill();
    
    // === FISH BODY ===
    // Body outline
    ctx.fillStyle = "#cc5500";
    ctx.beginPath();
    ctx.ellipse(8, 8, 9, 7, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Body main (orange)
    ctx.fillStyle = "#ff7722";
    ctx.beginPath();
    ctx.ellipse(8, 8, 8, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Body highlight
    ctx.fillStyle = "#ff9944";
    ctx.beginPath();
    ctx.ellipse(6, 5, 5, 3, -0.3, 0, Math.PI * 2);
    ctx.fill();
    
    // Belly
    ctx.fillStyle = "#ffcc88";
    ctx.beginPath();
    ctx.ellipse(8, 11, 5, 2.5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // === TAIL ===
    var tailWag = Math.sin(anim * 0.25) * 0.3;
    ctx.save();
    ctx.translate(16, 8);
    ctx.rotate(tailWag);
    
    ctx.fillStyle = "#cc5500";
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(7, -5);
    ctx.lineTo(5, 0);
    ctx.lineTo(7, 5);
    ctx.closePath();
    ctx.fill();
    
    ctx.fillStyle = "#ff7722";
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(6, -4);
    ctx.lineTo(4, 0);
    ctx.lineTo(6, 4);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
    
    // === FINS ===
    // Top fin
    ctx.fillStyle = "#cc5500";
    ctx.beginPath();
    ctx.moveTo(6, 2);
    ctx.lineTo(8, -3);
    ctx.lineTo(12, 2);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "#ff7722";
    ctx.beginPath();
    ctx.moveTo(7, 2);
    ctx.lineTo(8, -1);
    ctx.lineTo(11, 2);
    ctx.closePath();
    ctx.fill();
    
    // Bottom fin
    ctx.fillStyle = "#cc5500";
    ctx.beginPath();
    ctx.moveTo(8, 14);
    ctx.lineTo(6, 17);
    ctx.lineTo(11, 14);
    ctx.closePath();
    ctx.fill();
    
    // Side fin
    var finWave = Math.sin(anim * 0.3) * 0.4;
    ctx.save();
    ctx.translate(3, 10);
    ctx.rotate(finWave);
    ctx.fillStyle = "#ff9944";
    ctx.beginPath();
    ctx.ellipse(0, 0, 2, 4, -0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    
    // === SCALES (subtle @ pattern) ===
    ctx.fillStyle = "rgba(200,80,0,0.3)";
    ctx.font = "4px monospace";
    ctx.fillText("@", 5, 8);
    ctx.fillText("@", 9, 10);
    ctx.fillText("@", 7, 6);
    
    // === FACE ===
    var blinkFrame = Math.floor(anim) % 90;
    var isBlinking = blinkFrame > 85;
    var lookX = Math.sin(anim * 0.08) * 1;
    var lookY = Math.cos(anim * 0.06) * 0.5;
    
    // Eye socket
    ctx.fillStyle = "#aa4400";
    ctx.beginPath();
    ctx.ellipse(3, 6, 4, isBlinking ? 1 : 4, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Eye white
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.ellipse(3, 6, 3.5, isBlinking ? 0.5 : 3.5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    if (!isBlinking) {
      // Pupil (shifty, suspicious)
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.arc(3 + lookX, 6 + lookY, 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Tiny pupil (beady)
      ctx.fillStyle = "#222";
      ctx.beginPath();
      ctx.arc(3 + lookX, 6 + lookY, 1.2, 0, Math.PI * 2);
      ctx.fill();
      
      // Eye shine
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(2 + lookX, 5 + lookY, 1, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Suspicious/devious eyebrow
    ctx.strokeStyle = "#884400";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-1, 3);
    ctx.lineTo(4, 2);
    ctx.stroke();
    
    // === DEVIOUS GRIN ===
    // Mouth
    ctx.fillStyle = "#660000";
    ctx.beginPath();
    ctx.moveTo(0, 10);
    ctx.quadraticCurveTo(2, 13, 5, 10);
    ctx.quadraticCurveTo(2, 11, 0, 10);
    ctx.fill();
    
    // Sharp teeth
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.moveTo(0.5, 10);
    ctx.lineTo(1.2, 12);
    ctx.lineTo(2, 10);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(2.5, 10);
    ctx.lineTo(3.2, 12);
    ctx.lineTo(4, 10);
    ctx.fill();
    
    // === BUBBLES ===
    ctx.fillStyle = "rgba(150,200,255,0.5)";
    var bubbleT = (anim * 0.1) % 10;
    ctx.beginPath();
    ctx.arc(-2, 4 - bubbleT, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(0, 2 - (bubbleT + 3) % 10, 1, 0, Math.PI * 2);
    ctx.fill();
  
  ctx.restore();
}


// ============================================================
// DRAWING - HACKER (Hooded Figure with Laptop)
// ============================================================
function drawHacker(x, y, anim, state, squash = 1) {
  ctx.save();
  ctx.translate(x + 8, y + 16);
  ctx.scale(1, squash);
  ctx.translate(-8, -16);
  
  // Scale to fit 16x16 hitbox
  ctx.translate(8, 8);
  ctx.scale(0.87, 0.87);
  ctx.translate(-8, -8);
  
  var isChasing = state === "chase";
  var isAlert = state === "alert";
  var bounce = Math.sin(anim * 0.1) * 0.5;
  ctx.translate(0, bounce);
  
  // Shadow
  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.beginPath();
  ctx.ellipse(8, 20, 8, 2, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // === LAPTOP (in front, glowing) ===
  var laptopGlow = isChasing ? "rgba(255,0,0," : (isAlert ? "rgba(255,200,0," : "rgba(0,255,100,");
  var glowPulse = Math.sin(anim * 0.15) * 0.2 + 0.4;
  
  // Laptop glow on ground/figure
  ctx.fillStyle = laptopGlow + glowPulse + ")";
  ctx.beginPath();
  ctx.ellipse(8, 16, 10, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // === HUNCHED BODY (dark hoodie) ===
  ctx.fillStyle = isChasing ? "#1a0808" : "#0a0a12";
  ctx.beginPath();
  ctx.moveTo(0, 8);
  ctx.quadraticCurveTo(-2, 14, 0, 19);
  ctx.lineTo(16, 19);
  ctx.quadraticCurveTo(18, 14, 16, 8);
  ctx.quadraticCurveTo(8, 6, 0, 8);
  ctx.fill();
  
  // Body highlight
  ctx.fillStyle = isChasing ? "#2a1212" : "#151520";
  ctx.beginPath();
  ctx.moveTo(2, 10);
  ctx.quadraticCurveTo(4, 14, 4, 17);
  ctx.lineTo(8, 17);
  ctx.quadraticCurveTo(6, 12, 4, 9);
  ctx.closePath();
  ctx.fill();
  
  // === HOOD (large, shadowy) ===
  ctx.fillStyle = isChasing ? "#120606" : "#080810";
  ctx.beginPath();
  ctx.moveTo(-1, 12);
  ctx.quadraticCurveTo(-3, 4, 2, -2);
  ctx.quadraticCurveTo(8, -6, 14, -2);
  ctx.quadraticCurveTo(19, 4, 17, 12);
  ctx.quadraticCurveTo(8, 10, -1, 12);
  ctx.fill();
  
  // Hood rim
  ctx.strokeStyle = isChasing ? "#2a1515" : "#1a1a28";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, 11);
  ctx.quadraticCurveTo(8, 8, 16, 11);
  ctx.stroke();
  
  // Face void (deep shadow inside hood)
  ctx.fillStyle = "#000003";
  ctx.beginPath();
  ctx.ellipse(8, 5, 5, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // === GLOWING EYES IN THE VOID ===
  var eyeColor = isChasing ? "#ff0000" : (isAlert ? "#ffcc00" : "#00ff66");
  var eyePulse = Math.sin(anim * 0.2) * 0.3 + 0.7;
  
  // Eye glow
  ctx.fillStyle = laptopGlow + (eyePulse * 0.5) + ")";
  ctx.beginPath();
  ctx.arc(5.5, 4, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(10.5, 4, 3, 0, Math.PI * 2);
  ctx.fill();
  
  // Eye cores
  ctx.fillStyle = eyeColor;
  ctx.beginPath();
  ctx.arc(5.5, 4, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(10.5, 4, 2, 0, Math.PI * 2);
  ctx.fill();
  
  // Slit pupils
  ctx.fillStyle = "#000";
  ctx.fillRect(5, 3, 1, 2.5);
  ctx.fillRect(10, 3, 1, 2.5);
  
  // === LAPTOP ===
  // Base
  ctx.fillStyle = "#222";
  ctx.fillRect(2, 14, 12, 2);
  
  // Screen (angled up toward figure)
  ctx.fillStyle = "#111";
  ctx.beginPath();
  ctx.moveTo(3, 14);
  ctx.lineTo(4, 9);
  ctx.lineTo(12, 9);
  ctx.lineTo(13, 14);
  ctx.closePath();
  ctx.fill();
  
  // Screen content (code/hack stuff)
  ctx.fillStyle = isChasing ? "#ff3333" : (isAlert ? "#ffcc00" : "#00ff44");
  ctx.fillRect(5, 10, 6, 0.8);
  ctx.fillRect(5, 11.2, 4, 0.8);
  ctx.fillRect(5, 12.4, 5, 0.8);
  
  // Screen glow on face
  ctx.fillStyle = laptopGlow + "0.3)";
  ctx.beginPath();
  ctx.ellipse(8, 8, 4, 3, 0, 0, Math.PI);
  ctx.fill();
  
  // === HANDS ON KEYBOARD ===
  var typeAnim = Math.sin(anim * 0.4) * 0.5;
  ctx.fillStyle = isChasing ? "#1a0808" : "#0a0a12";
  ctx.beginPath();
  ctx.ellipse(5, 15 + typeAnim, 2, 1.5, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(11, 15 - typeAnim, 2, 1.5, 0.3, 0, Math.PI * 2);
  ctx.fill();
  
  // === MATRIX CODE PARTICLES (falling around hacker) ===
  var codeColor = isChasing ? "rgba(255,50,50," : (isAlert ? "rgba(255,200,50," : "rgba(0,255,100,");
  ctx.font = "bold 4px monospace";
  var chars = ["0", "1", "#", "$", "%", "@", "&", "<", ">", "/"];
  
  for (var p = 0; p < 8; p++) {
    // Each particle has its own phase and position
    var pSpeed = 0.08 + (p % 3) * 0.02;
    var pPhase = (anim * pSpeed + p * 37) % 30;
    var pX = -6 + (p * 4.3) % 28;
    var pY = -12 + pPhase;
    
    // Fade in at top, fade out at bottom
    var pAlpha = 1;
    if (pPhase < 5) pAlpha = pPhase / 5;
    if (pPhase > 25) pAlpha = (30 - pPhase) / 5;
    
    // Only draw if visible
    if (pAlpha > 0 && pY < 22) {
      ctx.fillStyle = codeColor + (pAlpha * 0.7) + ")";
      var charIndex = Math.floor(anim * 0.1 + p * 3) % 10;
      ctx.fillText(chars[charIndex], pX, pY);
    }
  }
  
  // === CHASE EFFECTS ===
  if (isChasing) {
    // Danger aura
    ctx.strokeStyle = "rgba(255,0,0,0.3)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.ellipse(8, 10, 12, 13, 0, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  if (isAlert) {
    // Alert indicator
    ctx.fillStyle = "#ffcc00";
    ctx.beginPath();
    ctx.arc(16, -2, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#000";
    ctx.font = "bold 6px sans-serif";
    ctx.fillText("!", 14.3, 1);
  }
  
  ctx.restore();
}


// ============================================================
// DRAWING - CREDENTIAL STUFFER (Keyboard Bot)
// ============================================================
function drawCredentialStealer(x, y, anim, state, squash = 1) {
  ctx.save();
  ctx.translate(x + 8, y + 16);
  ctx.scale(1, squash);
  ctx.translate(-8, -16);
  
  // Scale to fit 16x16 hitbox
  ctx.translate(8, 8);
  ctx.scale(0.84, 0.84);
  ctx.translate(-8, -8);
  
  var isFlying = state === "flyup" || state === "flyover" || state === "drop";
  var isAggro = state === "hesitate" || state === "approach";
  var bounce = Math.sin(anim * 0.12) * 1;
  
  // Stuffing animation
  var stuffCycle = anim % 120;
  var isStuffing = stuffCycle > 80 && !isFlying;
  
  ctx.translate(0, isFlying ? -4 : bounce);
  
  // Shadow
  ctx.fillStyle = "rgba(0,0,0," + (isFlying ? "0.15" : "0.3") + ")";
  ctx.beginPath();
  ctx.ellipse(8, isFlying ? 24 : 20 - bounce, 7, 2, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // === PROPELLER (when flying) ===
  if (isFlying) {
    var propAngle = anim * 0.8;
    ctx.strokeStyle = "#667";
    ctx.lineWidth = 2;
    ctx.save();
    ctx.translate(8, -4);
    ctx.rotate(propAngle);
    ctx.beginPath();
    ctx.moveTo(-8, 0);
    ctx.lineTo(8, 0);
    ctx.stroke();
    ctx.restore();
    // Propeller hub
    ctx.fillStyle = "#555";
    ctx.beginPath();
    ctx.arc(8, -4, 2, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // === BODY (chunky keyboard machine) ===
  // Body outline
  ctx.fillStyle = "#2a2a3a";
  ctx.beginPath();
  ctx.roundRect(-1, 4, 18, 14, 3);
  ctx.fill();
  
  // Body main
  ctx.fillStyle = isAggro ? "#4a4a5a" : "#3a3a4a";
  ctx.beginPath();
  ctx.roundRect(0, 5, 16, 12, 2);
  ctx.fill();
  
  // Body highlight
  ctx.fillStyle = isAggro ? "#5a5a6a" : "#4a4a5a";
  ctx.beginPath();
  ctx.roundRect(0, 5, 16, 3, [2, 2, 0, 0]);
  ctx.fill();
  
  // Keyboard keys on body (3x4 grid)
  ctx.fillStyle = "#222233";
  for (var row = 0; row < 3; row++) {
    for (var col = 0; col < 4; col++) {
      var keyBounce = isStuffing ? Math.sin(anim * 0.8 + row + col) * 0.5 : 0;
      ctx.fillRect(2 + col * 3.5, 7 + row * 3 + keyBounce, 2.5, 2);
    }
  }
  
  // Key labels (password chars)
  ctx.fillStyle = isAggro ? "#ff6666" : "#66ff66";
  ctx.font = "2px monospace";
  var chars = ["*", "*", "*", "*", "P", "A", "S", "S", "1", "2", "3", "4"];
  for (var k = 0; k < 12; k++) {
    var krow = Math.floor(k / 4);
    var kcol = k % 4;
    ctx.fillText(chars[k], 2.5 + kcol * 3.5, 8.5 + krow * 3);
  }
  
  // === HEAD (monitor with face) ===
  // Head outline
  ctx.fillStyle = "#1a1a2a";
  ctx.beginPath();
  ctx.roundRect(1, -6, 14, 11, 2);
  ctx.fill();
  
  // Screen
  ctx.fillStyle = "#0a0a12";
  ctx.beginPath();
  ctx.roundRect(2, -5, 12, 9, 1);
  ctx.fill();
  
  // Screen glow
  ctx.fillStyle = isAggro ? "rgba(255,50,50,0.15)" : "rgba(50,255,100,0.15)";
  ctx.beginPath();
  ctx.roundRect(2, -5, 12, 9, 1);
  ctx.fill();
  
  // === DIGITAL FACE ===
  var blinkFrame = Math.floor(anim) % 80;
  var isBlinking = blinkFrame > 75;
  
  // Eyes (blocky LED style)
  ctx.fillStyle = isAggro ? "#ff4444" : "#44ff88";
  if (!isBlinking) {
    // Left eye - square
    ctx.fillRect(4, -3, 3, 3);
    // Right eye - square
    ctx.fillRect(9, -3, 3, 3);
    // Pupils
    ctx.fillStyle = "#000";
    ctx.fillRect(5, -2, 1, 1);
    ctx.fillRect(10, -2, 1, 1);
  } else {
    // Closed eyes (horizontal lines)
    ctx.fillRect(4, -1, 3, 1);
    ctx.fillRect(9, -1, 3, 1);
  }
  
  // Mouth
  if (isStuffing) {
    // Open mouth - stuffing!
    ctx.fillStyle = "#000";
    ctx.fillRect(6, 1, 4, 2);
    ctx.fillStyle = isAggro ? "#ff4444" : "#44ff88";
    ctx.fillRect(6.5, 1.5, 1, 1);
    ctx.fillRect(8.5, 1.5, 1, 1);
  } else {
    // Flat line mouth
    ctx.fillStyle = isAggro ? "#ff4444" : "#44ff88";
    ctx.fillRect(5, 1, 6, 1);
  }
  
  // === MECHANICAL ARMS (waving up/down, opposing) ===
  var armWave = Math.sin(anim * 0.2) * 4;
  
  // Left arm (moves up when right moves down)
  ctx.fillStyle = "#444455";
  ctx.fillRect(-3, 8 - armWave, 4, 2);
  ctx.fillRect(-4, 10 - armWave, 3, 8);
  ctx.fillStyle = "#555566";
  ctx.beginPath();
  ctx.arc(-2.5, 19 - armWave, 2, 0, Math.PI * 2);
  ctx.fill();
  
  // Right arm (moves down when left moves up)
  ctx.fillStyle = "#444455";
  ctx.fillRect(15, 8 + armWave, 4, 2);
  ctx.fillRect(17, 10 + armWave, 3, 8);
  ctx.fillStyle = "#555566";
  ctx.beginPath();
  ctx.arc(18.5, 19 + armWave, 2, 0, Math.PI * 2);
  ctx.fill();
  
  // === STUFFING EFFECT (passwords shooting up) ===
  if (isStuffing) {
    ctx.fillStyle = "#ffff00";
    ctx.font = "bold 4px monospace";
    for (var s = 0; s < 4; s++) {
      var progress = ((stuffCycle - 80) / 40 + s * 0.25) % 1;
      var sy = 4 - progress * 18;
      var sx = 6 + s * 2;
      var alpha = 1 - progress;
      if (alpha > 0) {
        ctx.globalAlpha = alpha;
        ctx.fillText("*", sx, sy);
      }
    }
    ctx.globalAlpha = 1;
  }
  
  // === STATUS LED ===
  var ledBlink = Math.sin(anim * 0.3) > 0;
  ctx.fillStyle = isAggro ? (ledBlink ? "#ff0000" : "#440000") : (ledBlink ? "#00ff00" : "#004400");
  ctx.beginPath();
  ctx.arc(14, -6, 1.5, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.restore();
}


// ============================================================
// DRAWING - MALICIOUS ATTACHMENT (Level 1)
// ============================================================
function drawMaliciousAttachment(x, y, anim, squash = 1) {
  ctx.save();
  ctx.translate(x + 8, y + 16);
  ctx.scale(1, squash);
  ctx.translate(-8, -16);
  
  // Scale to fit 16x16 hitbox
  ctx.translate(8, 8);
  ctx.scale(0.84, 0.84);
  ctx.translate(-8, -8);
  
  var bounce = Math.sin(anim * 0.1) * 1;
  var sway = Math.sin(anim * 0.06) * 0.06;
  ctx.rotate(sway);
  ctx.translate(0, bounce);
  
  // === MASK SLIP ANIMATION ===
  // Every ~180 frames, mask slips down revealing evil face for 60 frames
  var maskCycle = anim % 240;
  var maskSlipping = maskCycle > 180;
  var slipAmount = maskSlipping ? Math.sin((maskCycle - 180) * 0.05) * 8 : 0;
  
  // Shadow
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.beginPath();
  ctx.ellipse(8, 22 - bounce, 6, 2, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // === BODY (professional, trustworthy appearance) ===
  // Business shirt
  ctx.fillStyle = "#4477bb";
  ctx.beginPath();
  ctx.moveTo(2, 10);
  ctx.lineTo(0, 22);
  ctx.lineTo(16, 22);
  ctx.lineTo(14, 10);
  ctx.closePath();
  ctx.fill();
  
  // Shirt collar
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.moveTo(5, 10);
  ctx.lineTo(8, 14);
  ctx.lineTo(11, 10);
  ctx.lineTo(10, 9);
  ctx.lineTo(8, 12);
  ctx.lineTo(6, 9);
  ctx.closePath();
  ctx.fill();
  
  // Professional tie
  ctx.fillStyle = "#cc3333";
  ctx.beginPath();
  ctx.moveTo(7, 12);
  ctx.lineTo(5.5, 22);
  ctx.lineTo(8, 19);
  ctx.lineTo(10.5, 22);
  ctx.lineTo(9, 12);
  ctx.closePath();
  ctx.fill();
  
  // Tie stripe
  ctx.strokeStyle = "#992222";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(8, 13);
  ctx.lineTo(8, 19);
  ctx.stroke();
  
  // === ARMS (welcoming gesture) ===
  var armWave = Math.sin(anim * 0.12) * 0.15;
  
  // Left arm
  ctx.save();
  ctx.translate(2, 12);
  ctx.rotate(-0.4 + armWave);
  ctx.fillStyle = "#4477bb";
  ctx.fillRect(-5, 0, 5, 9);
  // Hand
  ctx.fillStyle = "#ffddbb";
  ctx.beginPath();
  ctx.arc(-5, 9, 2.5, 0, Math.PI * 2);
  ctx.fill();
  // Waving fingers
  ctx.fillRect(-6, 7, 1, 3);
  ctx.fillRect(-4, 6, 1, 4);
  ctx.restore();
  
  // Right arm
  ctx.save();
  ctx.translate(14, 12);
  ctx.rotate(0.4 - armWave);
  ctx.fillStyle = "#4477bb";
  ctx.fillRect(0, 0, 5, 9);
  ctx.fillStyle = "#ffddbb";
  ctx.beginPath();
  ctx.arc(5, 9, 2.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillRect(4, 7, 1, 3);
  ctx.fillRect(5, 6, 1, 4);
  ctx.restore();
  
  // === TRUE EVIL FACE (underneath, only visible when mask slips) ===
  if (slipAmount > 0) {
    ctx.save();
    
    // Evil head
    ctx.fillStyle = "#881111";
    ctx.beginPath();
    ctx.ellipse(8, 4, 6, 7, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Horns
    ctx.fillStyle = "#550000";
    ctx.beginPath();
    ctx.moveTo(3, 0);
    ctx.lineTo(0, -6);
    ctx.lineTo(5, -1);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(13, 0);
    ctx.lineTo(16, -6);
    ctx.lineTo(11, -1);
    ctx.closePath();
    ctx.fill();
    
    // Evil yellow eyes (slits)
    ctx.fillStyle = "#ffff00";
    ctx.save();
    ctx.translate(5, 2);
    ctx.rotate(-0.2);
    ctx.beginPath();
    ctx.ellipse(0, 0, 2, 1.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    ctx.save();
    ctx.translate(11, 2);
    ctx.rotate(0.2);
    ctx.beginPath();
    ctx.ellipse(0, 0, 2, 1.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    
    // Slit pupils
    ctx.fillStyle = "#000";
    ctx.fillRect(4.5, 1, 1, 3);
    ctx.fillRect(10.5, 1, 1, 3);
    
    // Evil grin with sharp teeth
    ctx.fillStyle = "#330000";
    ctx.beginPath();
    ctx.arc(8, 7, 4, 0.1, Math.PI - 0.1);
    ctx.fill();
    
    // Sharp teeth
    ctx.fillStyle = "#fff";
    for (var t = 0; t < 6; t++) {
      ctx.beginPath();
      ctx.moveTo(4.5 + t * 1.4, 6);
      ctx.lineTo(5 + t * 1.4, 9);
      ctx.lineTo(5.5 + t * 1.4, 6);
      ctx.fill();
    }
    
    ctx.restore();
  }
  
  // === FRIENDLY MASK (slides down when slipping) ===
  ctx.save();
  ctx.translate(0, slipAmount);
  
  // Mask base shape (friendly face)
  ctx.fillStyle = "#ffe8cc";
  ctx.beginPath();
  ctx.ellipse(8, 3, 7, 8, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Mask edge highlight
  ctx.strokeStyle = "#ddccaa";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.ellipse(8, 3, 7, 8, 0, 0, Math.PI * 2);
  ctx.stroke();
  
  // Rosy cheeks (very friendly!)
  ctx.fillStyle = "rgba(255,150,150,0.5)";
  ctx.beginPath();
  ctx.ellipse(2, 4, 2.5, 1.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(14, 4, 2.5, 1.5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // === FRIENDLY EYES (or empty holes when slipping) ===
  if (!maskSlipping) {
    var blinkFrame = Math.floor(anim) % 80;
    var isBlinking = blinkFrame > 75;
    
    // Eye whites
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.ellipse(5, 1, 2.5, isBlinking ? 0.4 : 2.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(11, 1, 2.5, isBlinking ? 0.4 : 2.5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    if (!isBlinking) {
      // Friendly blue pupils
      var lookX = Math.sin(anim * 0.08) * 0.5;
      ctx.fillStyle = "#4488dd";
      ctx.beginPath();
      ctx.arc(5 + lookX, 1, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(11 + lookX, 1, 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Sparkle (extra friendly!)
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(4.5 + lookX, 0, 0.7, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(10.5 + lookX, 0, 0.7, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Happy eyebrows
    ctx.strokeStyle = "#bb9966";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(5, -2, 2, Math.PI * 0.7, Math.PI * 0.3, true);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(11, -2, 2, Math.PI * 0.7, Math.PI * 0.3, true);
    ctx.stroke();
  } else {
    // Empty eye holes showing evil eyes underneath
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(5, 1, 2.5, 2.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(11, 1, 2.5, 2.5, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // === BIG FRIENDLY SMILE ===
  // Lips
  ctx.fillStyle = "#ee8888";
  ctx.beginPath();
  ctx.arc(8, 6, 4.5, 0.15, Math.PI - 0.15);
  ctx.fill();
  
  // Teeth (perfect and white)
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(8, 6, 3.5, 0.2, Math.PI - 0.2);
  ctx.fill();
  
  // Tooth line
  ctx.strokeStyle = "#ddd";
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(8, 6);
  ctx.lineTo(8, 8.5);
  ctx.stroke();
  
  // === MASK STRAPS ===
  ctx.strokeStyle = "#888";
  ctx.lineWidth = 1.5;
  // Left strap
  ctx.beginPath();
  ctx.moveTo(1, 3);
  ctx.lineTo(-2, 2);
  ctx.stroke();
  // Right strap
  ctx.beginPath();
  ctx.moveTo(15, 3);
  ctx.lineTo(18, 2);
  ctx.stroke();
  
  ctx.restore();
  
  // === SUBTLE EVIL HINTS ===
  // Occasional red glitch (something's wrong...)
  if (Math.floor(anim * 0.2) % 15 === 0 && !maskSlipping) {
    ctx.fillStyle = "rgba(255,0,0,0.2)";
    ctx.fillRect(1, (anim * 2) % 18, 14, 1);
  }
  
  // Evil aura when mask slips
  if (maskSlipping) {
    var aura = Math.sin(anim * 0.15) * 0.25 + 0.35;
    ctx.strokeStyle = "rgba(255,0,0," + aura + ")";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(8, 8, 14, 16, 0, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  ctx.restore();
}

// ============================================================
// DRAWING - ROGUE ACCESS POINT (Level 2)
// ============================================================
function drawRogueAP(x, y, anim, dangerRadius, squash = 1) {
  ctx.save();
  ctx.translate(x + 8, y + 16);
  ctx.scale(1, squash);
  ctx.translate(-8, -16);
  
  // Scale to fit 16x16 hitbox
  ctx.translate(8, 8);
  ctx.scale(0.85, 0.85);
  ctx.translate(-8, -8);
  
  var hover = Math.sin(anim * 0.05) * 3;
  var lean = Math.sin(anim * 0.04) * 0.05;
  ctx.rotate(lean);
  ctx.translate(0, hover);
  
  // Shadow
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.beginPath();
  ctx.ellipse(8, 24 - hover, 10, 2.5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // === WIFI WAVES ===
  for (var w = 2; w >= 0; w--) {
    var phase = (anim * 0.04 + w * 0.35) % 1;
    var alpha = 0.8 - phase * 0.7;
    ctx.strokeStyle = "rgba(255,50,50," + alpha + ")";
    ctx.lineWidth = 3;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.arc(8, 0, 6 + w * 6 + phase * 6, -Math.PI * 0.8, -Math.PI * 0.2);
    ctx.stroke();
  }
  
  // === ROUTER BODY ===
  // Body dark edge
  ctx.fillStyle = "#08080f";
  ctx.beginPath();
  ctx.roundRect(-2, 5, 20, 14, 3);
  ctx.fill();
  
  // Body main
  ctx.fillStyle = "#1a1a2e";
  ctx.beginPath();
  ctx.roundRect(-1, 6, 18, 12, 2);
  ctx.fill();
  
  // Body top highlight
  ctx.fillStyle = "#2a2a4a";
  ctx.beginPath();
  ctx.roundRect(-1, 6, 18, 4, [2, 2, 0, 0]);
  ctx.fill();
  
  // Body shadow
  ctx.fillStyle = "#0f0f1a";
  ctx.fillRect(-1, 15, 18, 3);
  
  // Vent grilles
  ctx.fillStyle = "#08080f";
  for (var v = 0; v < 5; v++) {
    ctx.fillRect(1 + v * 3.2, 10, 2.5, 1);
    ctx.fillRect(1 + v * 3.2, 12, 2.5, 1);
  }
  
  // === ANTENNA WITH EYE ===
  // Antenna stalk
  ctx.fillStyle = "#222230";
  ctx.fillRect(6, -5, 4, 11);
  ctx.fillStyle = "#333340";
  ctx.fillRect(6.5, -4, 3, 10);
  ctx.fillStyle = "#444450";
  ctx.fillRect(7, -3, 2, 9);
  
  // Eye socket (dark edge)
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.arc(8, -7, 6, 0, Math.PI * 2);
  ctx.fill();
  
  // Eye white
  ctx.fillStyle = "#fff8f8";
  ctx.beginPath();
  ctx.arc(8, -7, 5, 0, Math.PI * 2);
  ctx.fill();
  
  // Bloodshot veins
  ctx.strokeStyle = "rgba(200,50,50,0.4)";
  ctx.lineWidth = 0.5;
  for (var vein = 0; vein < 5; vein++) {
    var vAngle = vein * Math.PI / 2.5 + 0.2;
    ctx.beginPath();
    ctx.moveTo(8 + Math.cos(vAngle) * 2, -7 + Math.sin(vAngle) * 2);
    ctx.lineTo(8 + Math.cos(vAngle) * 5, -7 + Math.sin(vAngle) * 5);
    ctx.stroke();
  }
  
  // Iris
  var lookX = Math.sin(anim * 0.07) * 1.5;
  var lookY = Math.cos(anim * 0.05) * 0.8;
  ctx.fillStyle = "#cc0000";
  ctx.beginPath();
  ctx.arc(8 + lookX, -7 + lookY, 3, 0, Math.PI * 2);
  ctx.fill();
  
  // Iris detail
  ctx.fillStyle = "#aa0000";
  ctx.beginPath();
  ctx.arc(8 + lookX, -7 + lookY, 2, 0, Math.PI * 2);
  ctx.fill();
  
  // Pupil
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.arc(8 + lookX, -7 + lookY, 1.3, 0, Math.PI * 2);
  ctx.fill();
  
  // Eye shine
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.arc(7 + lookX, -8 + lookY, 1, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(9 + lookX, -6 + lookY, 0.4, 0, Math.PI * 2);
  ctx.fill();
  
  // Eye glow
  var eyeGlow = Math.sin(anim * 0.2) * 0.2 + 0.25;
  ctx.fillStyle = "rgba(255,0,0," + eyeGlow + ")";
  ctx.beginPath();
  ctx.arc(8, -7, 6, 0, Math.PI * 2);
  ctx.fill();
  
  // Angry eyebrow
  ctx.strokeStyle = "#cc0000";
  ctx.lineWidth = 2.5;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(2, -11);
  ctx.lineTo(8, -13);
  ctx.lineTo(14, -11);
  ctx.stroke();
  
  // === STATUS LEDS ===
  var ledPhase = Math.floor(anim * 0.1) % 5;
  for (var led = 0; led < 5; led++) {
    var isLit = led <= ledPhase;
    ctx.fillStyle = isLit ? "rgba(0,255,68,0.3)" : "transparent";
    ctx.beginPath();
    ctx.arc(1 + led * 3.2, 8, 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = isLit ? "#00ff44" : "#002211";
    ctx.beginPath();
    ctx.arc(1 + led * 3.2, 8, 1.2, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // === FACE ON ROUTER ===
  var blinkFrame = Math.floor(anim) % 120;
  var isBlinking = blinkFrame > 115;
  
  // LED eyes
  ctx.fillStyle = "rgba(255,0,0,0.3)";
  ctx.fillRect(2, 14, 4, 3);
  ctx.fillRect(10, 14, 4, 3);
  
  ctx.fillStyle = "#ff0000";
  if (!isBlinking) {
    ctx.fillRect(3, 14.5, 2, 2);
    ctx.fillRect(11, 14.5, 2, 2);
    // Eye shine
    ctx.fillStyle = "#ff6666";
    ctx.fillRect(3, 14.5, 1, 1);
    ctx.fillRect(11, 14.5, 1, 1);
  } else {
    ctx.fillRect(3, 15.5, 2, 0.5);
    ctx.fillRect(11, 15.5, 2, 0.5);
  }
  
  ctx.restore();
}

// ============================================================
// DRAWING - PACKET SNIFFER (Level 2)
// ============================================================
function drawPacketSniffer(x, y, anim, squash = 1) {
  ctx.save();
  ctx.translate(x + 8, y + 16);
  ctx.scale(1, squash);
  ctx.translate(-8, -16);
  
  // Scale to fit 16x16 hitbox
  ctx.translate(8, 8);
  ctx.scale(0.72, 0.72);
  ctx.translate(-8, -8);
  
  var breathe = Math.sin(anim * 0.08) * 1;
  var lean = Math.sin(anim * 0.05) * 0.04;
  ctx.rotate(lean);
  ctx.translate(0, breathe);
  
  // Shadow
  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.beginPath();
  ctx.ellipse(8, 20 - breathe, 10, 2.5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // === HEADBAND ===
  ctx.strokeStyle = "#1a1a2a";
  ctx.lineWidth = 5;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.arc(8, 6, 14, Math.PI * 1.1, Math.PI * 1.9);
  ctx.stroke();
  
  ctx.strokeStyle = "#2a2a3a";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(8, 6, 13, Math.PI * 1.15, Math.PI * 1.85);
  ctx.stroke();
  
  // === HEADPHONE EARS ===
  // Left ear - dark edge
  ctx.fillStyle = "#0a0a15";
  ctx.beginPath();
  ctx.roundRect(-7, 0, 8, 15, 3);
  ctx.fill();
  
  // Left ear - main
  ctx.fillStyle = "#2a2a3a";
  ctx.beginPath();
  ctx.roundRect(-6, 1, 6, 13, 2);
  ctx.fill();
  
  // Left ear - highlight
  ctx.fillStyle = "#3a3a4a";
  ctx.beginPath();
  ctx.roundRect(-6, 1, 6, 4, [2, 2, 0, 0]);
  ctx.fill();
  
  // Left cushion
  ctx.fillStyle = "#1a1a25";
  ctx.beginPath();
  ctx.roundRect(-5, 3, 4, 9, 1);
  ctx.fill();
  
  // Right ear - dark edge
  ctx.fillStyle = "#0a0a15";
  ctx.beginPath();
  ctx.roundRect(15, 0, 8, 15, 3);
  ctx.fill();
  
  // Right ear - main
  ctx.fillStyle = "#2a2a3a";
  ctx.beginPath();
  ctx.roundRect(16, 1, 6, 13, 2);
  ctx.fill();
  
  // Right ear - highlight
  ctx.fillStyle = "#3a3a4a";
  ctx.beginPath();
  ctx.roundRect(16, 1, 6, 4, [2, 2, 0, 0]);
  ctx.fill();
  
  // Right cushion
  ctx.fillStyle = "#1a1a25";
  ctx.beginPath();
  ctx.roundRect(17, 3, 4, 9, 1);
  ctx.fill();
  
  // === SPHERE BODY ===
  // Body dark edge
  ctx.fillStyle = "#2a2a4a";
  ctx.beginPath();
  ctx.arc(8, 7, 11, 0, Math.PI * 2);
  ctx.fill();
  
  // Body main
  ctx.fillStyle = "#3a3a5a";
  ctx.beginPath();
  ctx.arc(8, 7, 10, 0, Math.PI * 2);
  ctx.fill();
  
  // Body highlight (upper left)
  ctx.fillStyle = "#5a5a8a";
  ctx.beginPath();
  ctx.arc(4, 2, 6, 0, Math.PI * 2);
  ctx.fill();
  
  // Body shine
  ctx.fillStyle = "#7a7aaa";
  ctx.beginPath();
  ctx.arc(3, 1, 3, 0, Math.PI * 2);
  ctx.fill();
  
  // Equator ring
  ctx.strokeStyle = "#4a4a6a";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(8, 7, 10, 3.5, 0, 0, Math.PI * 2);
  ctx.stroke();
  
  // === GIANT EYE ===
  // Eye socket (dark edge)
  ctx.fillStyle = "#0a0a15";
  ctx.beginPath();
  ctx.arc(8, 6, 8.5, 0, Math.PI * 2);
  ctx.fill();
  
  // Lens ring
  ctx.strokeStyle = "#555";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(8, 6, 7.5, 0, Math.PI * 2);
  ctx.stroke();
  
  // Eye white
  ctx.fillStyle = "#fff8f8";
  ctx.beginPath();
  ctx.arc(8, 6, 7, 0, Math.PI * 2);
  ctx.fill();
  
  // Bloodshot veins
  ctx.strokeStyle = "rgba(180,50,50,0.35)";
  ctx.lineWidth = 0.5;
  for (var v = 0; v < 8; v++) {
    var vAngle = v * Math.PI / 4 + anim * 0.003;
    ctx.beginPath();
    ctx.moveTo(8 + Math.cos(vAngle) * 2, 6 + Math.sin(vAngle) * 2);
    ctx.quadraticCurveTo(
      8 + Math.cos(vAngle + 0.2) * 4.5,
      6 + Math.sin(vAngle + 0.2) * 4.5,
      8 + Math.cos(vAngle) * 7,
      6 + Math.sin(vAngle) * 7
    );
    ctx.stroke();
  }
  
  // Iris (tracks player)
  var irisX = 8 + Math.sin(anim * 0.05) * 2;
  var irisY = 6 + Math.cos(anim * 0.04) * 1.5;
  
  // Iris outer
  ctx.fillStyle = "#1a6644";
  ctx.beginPath();
  ctx.arc(irisX, irisY, 5, 0, Math.PI * 2);
  ctx.fill();
  
  // Iris middle
  ctx.fillStyle = "#228855";
  ctx.beginPath();
  ctx.arc(irisX, irisY, 4, 0, Math.PI * 2);
  ctx.fill();
  
  // Iris pattern
  ctx.strokeStyle = "#115533";
  ctx.lineWidth = 0.5;
  for (var r = 0; r < 10; r++) {
    var rAngle = r * Math.PI / 5 + anim * 0.015;
    ctx.beginPath();
    ctx.moveTo(irisX + Math.cos(rAngle) * 1.5, irisY + Math.sin(rAngle) * 1.5);
    ctx.lineTo(irisX + Math.cos(rAngle) * 5, irisY + Math.sin(rAngle) * 5);
    ctx.stroke();
  }
  
  // Iris inner ring
  ctx.fillStyle = "#33aa77";
  ctx.beginPath();
  ctx.arc(irisX, irisY, 3, 0, Math.PI * 2);
  ctx.fill();
  
  // Pupil
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.arc(irisX, irisY, 2.2, 0, Math.PI * 2);
  ctx.fill();
  
  // Camera aperture blades in pupil
  ctx.strokeStyle = "#222";
  ctx.lineWidth = 0.7;
  for (var a = 0; a < 6; a++) {
    var aAngle = a * Math.PI / 3 + anim * 0.08;
    ctx.beginPath();
    ctx.arc(irisX, irisY, 1.5, aAngle, aAngle + 0.35);
    ctx.stroke();
  }
  
  // Eye shine (multiple)
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.arc(irisX - 1.5, irisY - 1.5, 1.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(irisX + 1.2, irisY + 1, 0.6, 0, Math.PI * 2);
  ctx.fill();
  
  // === SATELLITE DISH ===
  // Arm
  ctx.fillStyle = "#333";
  ctx.fillRect(6.5, -12, 3, 7);
  ctx.fillStyle = "#444";
  ctx.fillRect(7, -11, 2, 6);
  
  // Dish dark edge
  ctx.fillStyle = "#444";
  ctx.beginPath();
  ctx.ellipse(8, -14, 7, 3, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Dish main
  ctx.fillStyle = "#555";
  ctx.beginPath();
  ctx.ellipse(8, -14, 6, 2.5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Dish inner
  ctx.fillStyle = "#666";
  ctx.beginPath();
  ctx.ellipse(8, -14, 5, 2, Math.PI, 0, Math.PI);
  ctx.fill();
  
  // Dish highlight
  ctx.fillStyle = "#777";
  ctx.beginPath();
  ctx.ellipse(6, -14, 2, 1, 0, Math.PI * 0.7, Math.PI * 1.7);
  ctx.fill();
  
  // Receiver
  ctx.fillStyle = "#888";
  ctx.beginPath();
  ctx.arc(8, -14, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = "#999";
  ctx.beginPath();
  ctx.arc(7.5, -14.5, 0.8, 0, Math.PI * 2);
  ctx.fill();
  
  // Signal receiving animation
  var sigPhase = (anim * 0.1) % 1;
  ctx.strokeStyle = "rgba(0,255,100," + (1 - sigPhase) + ")";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(8, -14, 3 + sigPhase * 6, -Math.PI * 0.75, -Math.PI * 0.25);
  ctx.stroke();
  
  // === REC INDICATOR ===
  var recOn = Math.sin(anim * 0.25) > 0;
  
  // REC glow
  ctx.fillStyle = recOn ? "rgba(255,0,0,0.4)" : "transparent";
  ctx.beginPath();
  ctx.arc(16, -3, 4, 0, Math.PI * 2);
  ctx.fill();
  
  // REC dot
  ctx.fillStyle = recOn ? "#ff0000" : "#330000";
  ctx.beginPath();
  ctx.arc(16, -3, 2.5, 0, Math.PI * 2);
  ctx.fill();
  
  // REC shine
  if (recOn) {
    ctx.fillStyle = "#ff6666";
    ctx.beginPath();
    ctx.arc(15, -4, 1, 0, Math.PI * 2);
    ctx.fill();
    
    // REC text
    ctx.fillStyle = "#ff0000";
    ctx.font = "bold 3.5px sans-serif";
    ctx.fillText("REC", 10, -7);
  }
  
  // === DATA CAPTURE ===
  ctx.font = "3px monospace";
  for (var d = 0; d < 6; d++) {
    var dAngle = anim * 0.06 + d * 1.1;
    var dDist = 15 + d * 3;
    var dX = 8 + Math.cos(dAngle) * dDist;
    var dY = 6 + Math.sin(dAngle) * (dDist * 0.5);
    var dAlpha = 0.8 - d * 0.1;
    var chars = ["0", "1", "@", "#", "$", "%"];
    ctx.fillStyle = "rgba(0,255,100," + dAlpha + ")";
    ctx.fillText(chars[d % 6], dX, dY);
  }
  
  ctx.restore();
}

// ============================================================
// DRAWING - RANSOMWARE (Evil Padlock)
// ============================================================
function drawRansomwareLock(x, y, anim, squash = 1) {
  ctx.save();
  ctx.translate(x + 8, y + 16);
  ctx.scale(1, squash);
  ctx.translate(-8, -16);
  
  // Scale to fit 16x16 hitbox
  ctx.translate(8, 8);
  ctx.scale(0.84, 0.84);
  ctx.translate(-8, -8);
  
  var bounce = Math.sin(anim * 0.08) * 1.5;
  var lean = Math.sin(anim * 0.05) * 0.04;
  ctx.rotate(lean);
  ctx.translate(0, bounce);
  
  // Ground shadow
  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.beginPath();
  ctx.ellipse(8, 22 - bounce, 7, 2, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // === PROMINENT SHACKLE (the defining lock feature) ===
  // Shackle legs (vertical bars going into body)
  // Left leg
  ctx.fillStyle = "#444450";
  ctx.fillRect(1, -2, 4, 12);
  ctx.fillStyle = "#888898";
  ctx.fillRect(2, -2, 2, 12);
  ctx.fillStyle = "#aaaabc";
  ctx.fillRect(2.5, -2, 1, 10);
  
  // Right leg
  ctx.fillStyle = "#444450";
  ctx.fillRect(11, -2, 4, 12);
  ctx.fillStyle = "#888898";
  ctx.fillRect(12, -2, 2, 12);
  ctx.fillStyle = "#aaaabc";
  ctx.fillRect(12.5, -2, 1, 10);
  
  // Shackle curve (connects the legs at top)
  ctx.strokeStyle = "#444450";
  ctx.lineWidth = 5;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.arc(8, 0, 5, Math.PI, 0);
  ctx.stroke();
  
  ctx.strokeStyle = "#888898";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(8, 0, 5, Math.PI, 0);
  ctx.stroke();
  
  // === LOCK BODY (classic padlock rectangle) ===
  // Body outline
  ctx.fillStyle = "#996600";
  ctx.beginPath();
  ctx.roundRect(-1, 6, 18, 14, 2);
  ctx.fill();
  
  // Body main (gold)
  ctx.fillStyle = "#ddaa00";
  ctx.beginPath();
  ctx.roundRect(0, 7, 16, 12, 2);
  ctx.fill();
  
  // Body top highlight
  ctx.fillStyle = "#ffcc33";
  ctx.beginPath();
  ctx.roundRect(0, 7, 16, 3, [2, 2, 0, 0]);
  ctx.fill();
  
  // Body right shadow
  ctx.fillStyle = "#bb8800";
  ctx.fillRect(13, 10, 3, 9);
  
  // Body bottom shadow
  ctx.fillStyle = "#aa7700";
  ctx.fillRect(0, 16, 16, 3);
  
  // === ANGRY FACE (on the lock body) ===
  // Eye sockets (dark)
  ctx.fillStyle = "#442200";
  ctx.beginPath();
  ctx.ellipse(5, 12, 2.5, 2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(11, 12, 2.5, 2, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Glowing red eyes
  var eyePulse = Math.sin(anim * 0.2) * 0.3 + 0.7;
  
  ctx.fillStyle = "rgba(255,0,0," + (eyePulse * 0.4) + ")";
  ctx.beginPath();
  ctx.arc(5, 12, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(11, 12, 3, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = "#ff0000";
  ctx.beginPath();
  ctx.arc(5, 12, 1.8, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(11, 12, 1.8, 0, Math.PI * 2);
  ctx.fill();
  
  // Pupil slits
  ctx.fillStyle = "#330000";
  ctx.fillRect(4.4, 11, 1.2, 2.5);
  ctx.fillRect(10.4, 11, 1.2, 2.5);
  
  // === KEYHOLE (centered, classic shape) ===
  ctx.fillStyle = "#111";
  ctx.beginPath();
  ctx.arc(8, 15, 1.8, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(7, 15);
  ctx.lineTo(6.5, 19);
  ctx.lineTo(9.5, 19);
  ctx.lineTo(9, 15);
  ctx.fill();
  
  // Keyhole inner (darker)
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.arc(8, 15, 1.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(7.3, 15);
  ctx.lineTo(7, 18);
  ctx.lineTo(9, 18);
  ctx.lineTo(8.7, 15);
  ctx.fill();
  
  // === DANGER AURA ===
  var auraPulse = Math.sin(anim * 0.12) * 0.15 + 0.2;
  ctx.strokeStyle = "rgba(255,50,0," + auraPulse + ")";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.ellipse(8, 12, 12, 14, 0, 0, Math.PI * 2);
  ctx.stroke();
  
  ctx.restore();
}


// ============================================================
// DRAWING - DATA EXFILTRATOR (Vacuum Portal)
// ============================================================
function drawDataExfiltrator(x, y, anim, squash = 1) {
  ctx.save();
  ctx.translate(x + 8, y + 16);
  ctx.scale(1, squash);
  ctx.translate(-8, -16);
  
  // Scale to fit 16x16 hitbox
  ctx.translate(8, 8);
  ctx.scale(0.92, 0.92);
  ctx.translate(-8, -8);
  
  var bounce = Math.sin(anim * 0.1) * 1.5;
  var lean = Math.sin(anim * 0.06) * 0.05;
  ctx.rotate(lean);
  ctx.translate(0, bounce);
  
  // Ground shadow
  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.beginPath();
  ctx.ellipse(8, 22 - bounce, 8, 2.5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // === DATA BEING SUCKED IN ===
  ctx.font = "4px monospace";
  for (var d = 0; d < 10; d++) {
    var spiralAngle = anim * 0.08 + d * 0.6;
    var spiralDist = 22 - ((anim * 0.4 + d * 2.5) % 20);
    var spiralX = 8 + Math.cos(spiralAngle) * spiralDist;
    var spiralY = 4 + Math.sin(spiralAngle) * (spiralDist * 0.35);
    var alpha = spiralDist / 22;
    
    if (spiralDist > 3) {
      var chars = ["0", "1", "$", "@", "#", "%", "&", "!", "?", "A"];
      ctx.fillStyle = "rgba(0,255,150," + alpha + ")";
      ctx.fillText(chars[d % 10], spiralX - 2, spiralY);
    }
  }
  
  // === VACUUM BODY (sleeker) ===
  // Body outline
  ctx.fillStyle = "#1a0a2a";
  ctx.beginPath();
  ctx.roundRect(-1, 6, 18, 14, 3);
  ctx.fill();
  
  // Body main
  ctx.fillStyle = "#3a1a4a";
  ctx.beginPath();
  ctx.roundRect(0, 7, 16, 12, 2);
  ctx.fill();
  
  // Body highlight
  ctx.fillStyle = "#5a2a6a";
  ctx.beginPath();
  ctx.roundRect(0, 7, 6, 10, [2, 0, 0, 2]);
  ctx.fill();
  
  // Body shadow
  ctx.fillStyle = "#2a0a3a";
  ctx.beginPath();
  ctx.roundRect(12, 7, 4, 12, [0, 2, 2, 0]);
  ctx.fill();
  
  // Panel detail
  ctx.strokeStyle = "#6a3a7a";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(5, 8);
  ctx.lineTo(5, 18);
  ctx.moveTo(11, 8);
  ctx.lineTo(11, 18);
  ctx.stroke();
  
  // === SUCTION VOID (the face IS the void) ===
  // Outer rim
  ctx.fillStyle = "#0a0015";
  ctx.beginPath();
  ctx.ellipse(8, 4, 9, 6, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Void ring
  ctx.fillStyle = "#1a0030";
  ctx.beginPath();
  ctx.ellipse(8, 4, 7.5, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Inner void (pure black)
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.ellipse(8, 4, 6, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Swirling vortex
  for (var v = 0; v < 4; v++) {
    var vPhase = (anim * 0.12 + v * 0.5) % 1;
    var vAlpha = 0.7 - vPhase * 0.6;
    ctx.strokeStyle = "rgba(180,80,220," + vAlpha + ")";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.ellipse(8, 4, 5 * vPhase, 3.5 * vPhase, anim * 0.08 + v, 0, Math.PI * 1.7);
    ctx.stroke();
  }
  
  // Inner glow (pulsing)
  var innerPulse = Math.sin(anim * 0.15) * 0.4 + 0.6;
  ctx.fillStyle = "rgba(200,100,255," + innerPulse + ")";
  ctx.beginPath();
  ctx.ellipse(8, 4, 2, 1.2, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Core shine
  ctx.fillStyle = "rgba(255,200,255,0.9)";
  ctx.beginPath();
  ctx.ellipse(7, 3.5, 0.8, 0.5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // === ANGRY EYES (above the void) ===
  var blinkFrame = Math.floor(anim) % 100;
  var isBlinking = blinkFrame > 95;
  var eyePulse = Math.sin(anim * 0.2) * 0.3 + 0.7;
  
  // Eye sockets
  ctx.fillStyle = "#1a0030";
  ctx.beginPath();
  ctx.ellipse(4, -2, 3, isBlinking ? 1 : 2.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(12, -2, 3, isBlinking ? 1 : 2.5, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Eye glow
  ctx.fillStyle = "rgba(255,0,255," + (eyePulse * 0.5) + ")";
  ctx.beginPath();
  ctx.ellipse(4, -2, 3.5, isBlinking ? 1.5 : 3, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(12, -2, 3.5, isBlinking ? 1.5 : 3, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Eye cores
  ctx.fillStyle = "#ff00ff";
  ctx.beginPath();
  ctx.ellipse(4, -2, 2.5, isBlinking ? 0.5 : 2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(12, -2, 2.5, isBlinking ? 0.5 : 2, 0, 0, Math.PI * 2);
  ctx.fill();
  
  if (!isBlinking) {
    // Angry pupils (looking down at void hungrily)
    ctx.fillStyle = "#440044";
    ctx.beginPath();
    ctx.arc(4, -1.5, 1.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(12, -1.5, 1.2, 0, Math.PI * 2);
    ctx.fill();
    
    // Eye shine
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(3, -2.5, 0.7, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(11, -2.5, 0.7, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Angry eyebrows
  ctx.strokeStyle = "#aa00aa";
  ctx.lineWidth = 2;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(0, -4);
  ctx.lineTo(5, -3);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(16, -4);
  ctx.lineTo(11, -3);
  ctx.stroke();
  
  // === BASE GLOW ===
  var basePulse = Math.sin(anim * 0.1) * 0.15 + 0.2;
  ctx.strokeStyle = "rgba(180,80,220," + basePulse + ")";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.ellipse(8, 13, 10, 6, 0, 0, Math.PI * 2);
  ctx.stroke();
  
  ctx.restore();
}


// ============================================================
// DRAWING - SHIELD POWERUP (Level-aware)
// ============================================================
function getShieldInfo() {
  if (currentLevel === 1) {
    return { name: "DUO", color: BRAND.duoGreen, fullName: "DUO IDENTITY SHIELD" };
  } else if (currentLevel === 2) {
    return { name: "ISE", color: BRAND.ciscoBlue, fullName: "ISE NETWORK SHIELD" };
  } else {
    return { name: "ZT", color: "#9b59b6", fullName: "ZERO TRUST SHIELD" };
  }
}

function drawShieldPowerup(x, y, timer) {
  const shield = getShieldInfo();
  const bob = Math.sin(timer * 0.08) * 3;
  const glow = Math.sin(timer * 0.12) * 0.3 + 0.7;
  const cx = x + 7;
  const cy = y + 7 + bob;
  
  // Glow
  const r = parseInt(shield.color.slice(1,3), 16);
  const g = parseInt(shield.color.slice(3,5), 16);
  const b = parseInt(shield.color.slice(5,7), 16);
  ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${glow * 0.4})`;
  ctx.beginPath();
  ctx.arc(cx, cy, 10, 0, Math.PI * 2);
  ctx.fill();
  
  // Shield shape
  ctx.fillStyle = shield.color;
  ctx.beginPath();
  ctx.moveTo(cx, cy - 8);
  ctx.lineTo(cx + 7, cy - 4);
  ctx.lineTo(cx + 7, cy + 4);
  ctx.lineTo(cx, cy + 8);
  ctx.lineTo(cx - 7, cy + 4);
  ctx.lineTo(cx - 7, cy - 4);
  ctx.closePath();
  ctx.fill();
  
  // Shield text
  ctx.fillStyle = "#fff";
  ctx.font = "bold 5px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText(shield.name, cx, cy + 2);
  
  // Icon bars
  ctx.fillStyle = "#fff";
  const barHeights = [3, 5, 6, 5, 3];
  for (let i = 0; i < 5; i++) {
    ctx.fillRect(cx - 4 + i * 2, cy - 6, 1, barHeights[i]);
  }
}

// ============================================================
// LANDSCAPE BACKGROUNDS
// ============================================================
function drawBackground() {
  if (currentLevel === 1) {
    drawInboxLandscape();
  } else if (currentLevel === 2) {
    drawPerimeterLandscape();
  } else if (currentLevel === 3) {
    drawDataCenterLandscape();
  } else {
    // Fallback
    ctx.fillStyle = "#1a1a2e";
    ctx.fillRect(0, 0, W, H);
  }
}


// ============================================================
// LEVEL 1: THE INBOX - Corporate Skyline at Dawn
// ============================================================
function drawInboxLandscape() {
  const t = LEVEL_THEMES[1];
  const parallax = camera.x;
  
  // === SKY: Dawn gradient with sun glow ===
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, t.skyTop);
  skyGrad.addColorStop(0.4, t.skyMid);
  skyGrad.addColorStop(0.75, t.skyHorizon);
  skyGrad.addColorStop(1, t.skyGlow);
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);
  
  // === SUN: Rising sun at horizon (subtle) ===
  const sunX = W * 0.7 - parallax * 0.02;
  const sunY = H * 0.78;
  // Outer glow
  const sunGlow = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 80);
  sunGlow.addColorStop(0, "rgba(255,220,150,0.4)");
  sunGlow.addColorStop(0.5, "rgba(255,150,100,0.15)");
  sunGlow.addColorStop(1, "rgba(255,100,50,0)");
  ctx.fillStyle = sunGlow;
  ctx.fillRect(0, 0, W, H);
  // Sun disc
  ctx.fillStyle = "rgba(255,240,200,0.8)";
  ctx.beginPath();
  ctx.arc(sunX, sunY, 20, 0, Math.PI * 2);
  ctx.fill();
  
  // === FAR LAYER: Distant city skyline silhouette ===
  ctx.fillStyle = t.farSilhouette;
  const farOffset = parallax * 0.03;
  // Painted skyline - large shapes
  drawCitySkyline(farOffset, H * 0.55, 0.6, t.farSilhouette);
  
  // === MID LAYER: Closer buildings with windows ===
  const midOffset = parallax * 0.08;
  drawOfficeBuildings(midOffset, H * 0.45, 0.85, t.midSilhouette, t.windowGlow);
  
  // === NEAR LAYER: Rooftop elements ===
  const nearOffset = parallax * 0.15;
  drawRooftopElements(nearOffset, t.nearSilhouette);
  
  // === ATMOSPHERE: Subtle haze at horizon ===
  const hazeGrad = ctx.createLinearGradient(0, H * 0.6, 0, H);
  hazeGrad.addColorStop(0, "rgba(255,200,150,0)");
  hazeGrad.addColorStop(1, "rgba(255,200,150,0.1)");
  ctx.fillStyle = hazeGrad;
  ctx.fillRect(0, H * 0.6, W, H * 0.4);
}

function drawCitySkyline(offset, baseY, scale, color) {
  ctx.fillStyle = color;
  // Variety of building heights and widths
  const buildings = [
    { x: 0, w: 35, h: 60 },
    { x: 40, w: 25, h: 45 },
    { x: 70, w: 50, h: 90 },   // Tall tower
    { x: 125, w: 30, h: 55 },
    { x: 160, w: 45, h: 75 },
    { x: 210, w: 20, h: 40 },
    { x: 235, w: 60, h: 100 }, // Tallest
    { x: 300, w: 35, h: 50 },
    { x: 340, w: 40, h: 70 },
    { x: 385, w: 25, h: 45 },
    { x: 415, w: 55, h: 85 },
    { x: 475, w: 30, h: 55 },
  ];
  
  for (const b of buildings) {
    const bx = ((b.x * scale - offset) % 520) - 40;
    const bh = b.h * scale;
    const bw = b.w * scale;
    const by = baseY - bh + 50;
    ctx.fillRect(bx, by, bw, bh + 60);
    
    // Occasional antenna/spire on tall buildings
    if (b.h > 80) {
      ctx.fillRect(bx + bw/2 - 2, by - 15, 4, 15);
    }
  }
}

function drawOfficeBuildings(offset, baseY, scale, color, windowColor) {
  ctx.fillStyle = color;
  
  const buildings = [
    { x: 20, w: 55, h: 80, floors: 6 },
    { x: 90, w: 70, h: 100, floors: 8 },
    { x: 175, w: 45, h: 65, floors: 5 },
    { x: 235, w: 80, h: 120, floors: 10 },
    { x: 330, w: 50, h: 70, floors: 5 },
    { x: 395, w: 65, h: 95, floors: 7 },
  ];
  
  for (const b of buildings) {
    const bx = ((b.x - offset) % 480) - 50;
    const bh = b.h * scale;
    const bw = b.w * scale;
    const by = baseY - bh + 80;
    
    // Building body
    ctx.fillStyle = color;
    ctx.fillRect(bx, by, bw, bh + 40);
    
    // Windows - grid pattern, some lit
    ctx.fillStyle = windowColor;
    const floorHeight = (bh - 10) / b.floors;
    const windowsPerFloor = Math.floor(bw / 12);
    
    for (let floor = 0; floor < b.floors; floor++) {
      for (let win = 0; win < windowsPerFloor; win++) {
        // Random lit windows (seeded by position)
        const seed = (b.x + floor * 7 + win * 13) % 10;
        if (seed < 4) { // 40% lit
          const wx = bx + 6 + win * 11;
          const wy = by + 8 + floor * floorHeight;
          ctx.globalAlpha = 0.3 + (seed % 3) * 0.2;
          ctx.fillRect(wx, wy, 6, floorHeight - 4);
        }
      }
    }
    ctx.globalAlpha = 1;
  }
}

function drawRooftopElements(offset, color) {
  ctx.fillStyle = color;
  
  // Water tower
  const wtX = ((180 - offset) % 400) - 50;
  ctx.fillRect(wtX, H * 0.65, 25, 8);  // Tank
  ctx.fillRect(wtX + 5, H * 0.65 + 8, 4, 15); // Leg
  ctx.fillRect(wtX + 16, H * 0.65 + 8, 4, 15); // Leg
  
  // AC units
  for (let i = 0; i < 3; i++) {
    const acX = ((50 + i * 150 - offset) % 450) - 30;
    ctx.fillRect(acX, H * 0.72, 20, 12);
    ctx.fillRect(acX + 3, H * 0.72 - 3, 14, 3); // Fan housing
  }
  
  // Satellite dish
  const satX = ((320 - offset) % 400) - 30;
  ctx.beginPath();
  ctx.arc(satX, H * 0.68, 12, Math.PI * 0.8, Math.PI * 0.2, true);
  ctx.fill();
  ctx.fillRect(satX - 2, H * 0.68, 4, 12);
}


// ============================================================
// LEVEL 2: THE PERIMETER - Digital Void
// ============================================================
function drawPerimeterLandscape() {
  const t = LEVEL_THEMES[2];
  const parallax = camera.x;
  
  // === SKY: Deep void with subtle gradient ===
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, t.skyTop);
  skyGrad.addColorStop(0.5, t.skyMid);
  skyGrad.addColorStop(0.85, t.skyHorizon);
  skyGrad.addColorStop(1, t.skyGlow);
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);
  
  // === STARS/NODES: Distant points of light ===
  ctx.fillStyle = "rgba(0,255,255,0.4)";
  for (let i = 0; i < 30; i++) {
    const sx = (i * 97 + 20) % W;
    const sy = (i * 43 + 10) % (H * 0.5);
    const pulse = Math.sin(frame * 0.02 + i) * 0.3 + 0.7;
    ctx.globalAlpha = pulse * 0.5;
    ctx.beginPath();
    ctx.arc(sx, sy, 1 + (i % 3) * 0.5, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  
  // === GRID: Perspective grid converging to horizon ===
  drawPerspectiveGrid(t);
  
  // === FAR: Data towers on horizon ===
  const farOffset = parallax * 0.02;
  drawDataTowers(farOffset, t);
  
  // === MID: Light ribbon highways ===
  const midOffset = parallax * 0.06;
  drawLightRibbons(midOffset, t);
  
  // === NEAR: Circuit terrain ===
  const nearOffset = parallax * 0.12;
  drawCircuitTerrain(nearOffset, t);
  
  // === ATMOSPHERE: Subtle digital aurora ===
  const auroraY = H * 0.2;
  const auroraGrad = ctx.createLinearGradient(0, auroraY - 30, 0, auroraY + 30);
  auroraGrad.addColorStop(0, "rgba(0,255,255,0)");
  auroraGrad.addColorStop(0.5, "rgba(0,255,200,0.05)");
  auroraGrad.addColorStop(1, "rgba(0,255,255,0)");
  ctx.fillStyle = auroraGrad;
  const auroraWave = Math.sin(frame * 0.01) * 10;
  ctx.fillRect(0, auroraY - 30 + auroraWave, W, 60);
}

function drawPerspectiveGrid(t) {
  const horizonY = H * 0.6;
  const vanishX = W * 0.5;
  
  ctx.strokeStyle = t.gridLine;
  ctx.lineWidth = 1;
  
  // Horizontal lines (closer = lower = more opaque)
  for (let i = 0; i < 12; i++) {
    const progress = i / 12;
    const y = horizonY + progress * progress * (H - horizonY);
    ctx.globalAlpha = 0.03 + progress * 0.08;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
    ctx.stroke();
  }
  
  // Vertical lines converging to vanishing point
  for (let i = -8; i <= 8; i++) {
    const bottomX = vanishX + i * 40;
    ctx.globalAlpha = 0.05 - Math.abs(i) * 0.003;
    ctx.beginPath();
    ctx.moveTo(vanishX, horizonY);
    ctx.lineTo(bottomX, H);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

function drawDataTowers(offset, t) {
  const horizonY = H * 0.6;
  
  const towers = [
    { x: 50, h: 40, w: 8 },
    { x: 120, h: 55, w: 12 },
    { x: 180, h: 35, w: 6 },
    { x: 250, h: 70, w: 15 },
    { x: 320, h: 45, w: 10 },
    { x: 400, h: 60, w: 12 },
  ];
  
  for (const tower of towers) {
    const tx = ((tower.x - offset) % 480) - 40;
    const th = tower.h;
    const tw = tower.w;
    
    // Tower silhouette
    ctx.fillStyle = t.farSilhouette;
    ctx.fillRect(tx, horizonY - th, tw, th);
    
    // Glow at top
    ctx.fillStyle = t.gridLine;
    ctx.globalAlpha = 0.6;
    ctx.fillRect(tx + tw/2 - 1, horizonY - th - 2, 2, 2);
    ctx.globalAlpha = 1;
  }
}

function drawLightRibbons(offset, t) {
  ctx.strokeStyle = t.gridLine;
  ctx.lineWidth = 2;
  ctx.globalAlpha = 0.3;
  
  // Main ribbon stretching to horizon
  const horizonY = H * 0.6;
  const ribbonOffset = (frame * 0.5 + offset) % 200;
  
  for (let i = 0; i < 4; i++) {
    const startX = ((i * 200 - ribbonOffset) % 800) - 200;
    ctx.beginPath();
    ctx.moveTo(startX, H);
    ctx.quadraticCurveTo(startX + 50, H * 0.8, W * 0.5, horizonY);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

function drawCircuitTerrain(offset, t) {
  const baseY = H * 0.85;
  
  // Circuit pathways
  ctx.strokeStyle = t.midSilhouette;
  ctx.lineWidth = 3;
  
  for (let i = 0; i < 6; i++) {
    const px = ((i * 100 - offset) % 600) - 50;
    ctx.beginPath();
    ctx.moveTo(px, baseY);
    ctx.lineTo(px + 30, baseY);
    ctx.lineTo(px + 30, baseY - 15);
    ctx.lineTo(px + 60, baseY - 15);
    ctx.stroke();
    
    // Junction node
    ctx.fillStyle = t.accentLight;
    ctx.globalAlpha = 0.5 + Math.sin(frame * 0.05 + i) * 0.3;
    ctx.beginPath();
    ctx.arc(px + 30, baseY - 15, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}


// ============================================================  
// LEVEL 3: DATACENTER - Underground Cathedral
// ============================================================
function drawDataCenterLandscape() {
  const t = LEVEL_THEMES[3];
  const parallax = camera.x;
  
  // === CEILING/SKY: Industrial darkness ===
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, t.skyTop);
  skyGrad.addColorStop(0.3, t.skyMid);
  skyGrad.addColorStop(0.7, t.skyHorizon);
  skyGrad.addColorStop(1, t.skyGlow);
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);
  
  // === CEILING: Industrial infrastructure ===
  drawCeilingInfrastructure(parallax * 0.03, t);
  
  // === FAR: Endless server rows vanishing ===
  drawServerRows(parallax * 0.05, t, 0.5, H * 0.35);
  
  // === MID: Closer server columns ===
  drawServerColumns(parallax * 0.1, t, 0.8, H * 0.5);
  
  // === NEAR: Floor details ===
  drawFloorDetails(parallax * 0.15, t);
  
  // === ATMOSPHERE: Warning beacon glow ===
  const beaconPhase = (frame % 120) / 120;
  if (beaconPhase < 0.5) {
    const beaconGlow = ctx.createRadialGradient(W * 0.15, H * 0.3, 0, W * 0.15, H * 0.3, 100);
    beaconGlow.addColorStop(0, "rgba(255,50,50,0.15)");
    beaconGlow.addColorStop(1, "rgba(255,50,50,0)");
    ctx.fillStyle = beaconGlow;
    ctx.fillRect(0, 0, W, H);
  }
  
  // === ATMOSPHERE: Cooling haze ===
  const hazeGrad = ctx.createLinearGradient(0, H * 0.7, 0, H);
  hazeGrad.addColorStop(0, "rgba(100,120,150,0)");
  hazeGrad.addColorStop(1, "rgba(100,120,150,0.08)");
  ctx.fillStyle = hazeGrad;
  ctx.fillRect(0, H * 0.7, W, H * 0.3);
}

function drawCeilingInfrastructure(offset, t) {
  // Main pipe runs
  ctx.fillStyle = t.farSilhouette;
  
  // Large horizontal pipe
  ctx.fillRect(0, 15, W, 12);
  
  // Vertical supports
  for (let i = 0; i < 5; i++) {
    const sx = ((i * 120 - offset) % 600) - 50;
    ctx.fillRect(sx, 0, 8, 40);
  }
  
  // Cable trays
  ctx.fillStyle = t.midSilhouette;
  for (let i = 0; i < 4; i++) {
    const cx = ((i * 150 + 30 - offset) % 600) - 50;
    ctx.fillRect(cx, 30, 60, 6);
  }
  
  // Emergency light (single, subtle)
  const lightX = ((200 - offset * 0.5) % 300) + 50;
  ctx.fillStyle = t.accentLight;
  ctx.globalAlpha = 0.4;
  ctx.fillRect(lightX, 26, 12, 4);
  ctx.globalAlpha = 1;
}

function drawServerRows(offset, t, scale, baseY) {
  // Vanishing point perspective - rows of racks
  const vanishX = W * 0.5;
  
  ctx.fillStyle = t.farSilhouette;
  
  // Draw rows getting smaller toward horizon
  for (let row = 0; row < 6; row++) {
    const rowScale = 1 - row * 0.12;
    const rowY = baseY - row * 15 * scale;
    const rowWidth = 400 * rowScale;
    const rackWidth = 30 * rowScale;
    const rackHeight = 50 * rowScale;
    
    for (let i = 0; i < 8; i++) {
      const rx = vanishX - rowWidth/2 + ((i * 55 * rowScale - offset * rowScale) % rowWidth);
      ctx.fillRect(rx, rowY - rackHeight, rackWidth, rackHeight);
    }
  }
}

function drawServerColumns(offset, t, scale, baseY) {
  const columns = [
    { x: 30, h: 90 },
    { x: 130, h: 100 },
    { x: 250, h: 85 },
    { x: 350, h: 95 },
    { x: 450, h: 90 },
  ];
  
  for (const col of columns) {
    const cx = ((col.x - offset) % 520) - 40;
    const ch = col.h * scale;
    const cw = 35 * scale;
    
    // Rack body
    ctx.fillStyle = t.midSilhouette;
    ctx.fillRect(cx, baseY - ch, cw, ch + 30);
    
    // LED strips
    const ledRows = Math.floor(ch / 12);
    for (let led = 0; led < ledRows; led++) {
      const ledY = baseY - ch + 8 + led * 12;
      
      // Green status LED
      const greenOn = ((frame + col.x + led * 7) % 40) < 35;
      ctx.fillStyle = greenOn ? t.ledGreen : "#001100";
      ctx.globalAlpha = greenOn ? 0.8 : 0.3;
      ctx.fillRect(cx + 5, ledY, 3, 2);
      
      // Amber activity LED  
      const amberOn = ((frame + col.x + led * 11) % 20) < 10;
      ctx.fillStyle = amberOn ? t.ledAmber : "#111100";
      ctx.globalAlpha = amberOn ? 0.7 : 0.3;
      ctx.fillRect(cx + 12, ledY, 3, 2);
      
      ctx.globalAlpha = 1;
    }
  }
}

function drawFloorDetails(offset, t) {
  const floorY = H * 0.88;
  
  // Cable channels
  ctx.fillStyle = t.nearSilhouette;
  for (let i = 0; i < 4; i++) {
    const chX = ((i * 180 - offset) % 720) - 100;
    ctx.fillRect(chX, floorY, 80, 6);
    // Channel cover lines
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 1;
    for (let j = 0; j < 4; j++) {
      ctx.beginPath();
      ctx.moveTo(chX + 10 + j * 20, floorY);
      ctx.lineTo(chX + 10 + j * 20, floorY + 6);
      ctx.stroke();
    }
  }
  
  // Cooling vent
  const ventX = ((100 - offset) % 300) + 80;
  ctx.fillStyle = t.nearSilhouette;
  ctx.fillRect(ventX, floorY - 4, 40, 8);
  // Vent slits
  ctx.fillStyle = "#000";
  for (let s = 0; s < 5; s++) {
    ctx.fillRect(ventX + 4 + s * 8, floorY - 2, 4, 4);
  }
}


// ============================================================
// FOREGROUND - Minimal atmospheric touches
// ============================================================
// === HAZARD MUGS (foreground) ===
function drawHazardMugs() {
  if (!level.ground || !level.isDesktopWorld) return;
  
  const DESK_Y = 180;
  const camX = camera.x;
  
  for (let i = 0; i < level.ground.length - 1; i++) {
    const [gx1, gy1, gw1] = level.ground[i];
    const [gx2, gy2, gw2] = level.ground[i + 1];
    const gapStart = gx1 + gw1;
    const gapEnd = gx2;
    const gapW = gapEnd - gapStart;
    
    const screenStart = gapStart - camX;
    const screenEnd = gapEnd - camX;
    const screenMid = (screenStart + screenEnd) / 2;
    
    if (screenEnd < -30 || screenStart > W + 30) continue;
    
    const mugW = gapW - 6;
    const mugH = 48;
    const mugX = screenStart + 3;
    const mugY = DESK_Y + 4;
    
    // === HANDLE ===
    ctx.fillStyle = "#888";
    ctx.beginPath();
    ctx.ellipse(mugX + mugW + 10, mugY + mugH/2 + 2, 11, 14, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#E8E8E8";
    ctx.beginPath();
    ctx.ellipse(mugX + mugW + 8, mugY + mugH/2, 10, 13, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#1A1008";
    ctx.beginPath();
    ctx.ellipse(mugX + mugW + 8, mugY + mugH/2, 4, 7, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // === MUG BODY ===
    ctx.fillStyle = "#888";
    ctx.fillRect(mugX - 2, mugY + 2, mugW + 4, mugH);
    ctx.fillStyle = "#FFF";
    ctx.fillRect(mugX, mugY, mugW, mugH);
    
    // === RIM ===
    ctx.fillStyle = "#CCC";
    ctx.fillRect(mugX - 2, mugY - 2, mugW + 4, 3);
    ctx.fillStyle = "#FFF";
    ctx.fillRect(mugX - 1, mugY - 1, mugW + 2, 2);
    
    // === BOTTOM ===
    ctx.fillStyle = "#AAA";
    ctx.fillRect(mugX, mugY + mugH - 2, mugW, 2);
    
    // === TEXT ===
    ctx.save();
    ctx.fillStyle = "#000";
    ctx.font = "bold 8px Arial, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("WORLD'S", screenMid, mugY + 12);
    ctx.fillText("BEST", screenMid, mugY + 24);
    ctx.fillText("BOSS", screenMid, mugY + 36);
    ctx.restore();
    
    // === STEAM ===
    for (let s = 0; s < 4; s++) {
      const baseX = mugX + 8 + s * ((mugW - 16) / 3);
      const rise = (frame * 0.5 + s * 12) % 30;
      const steamY = mugY - 5 - rise;
      const wobble = Math.sin(frame * 0.06 + s * 1.8) * 4;
      const alpha = 0.5 - rise / 40;
      const size = 3 - rise / 15;
      if (alpha > 0.05 && size > 0.5) {
        ctx.fillStyle = "rgba(255,255,255," + alpha + ")";
        ctx.beginPath();
        ctx.arc(baseX + wobble, steamY, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
}

function drawForeground() {
  if (currentLevel === 1) {
    // Draw hazard mugs in foreground
    // Hazard mugs removed
    
    // Subtle lens flare from sun direction
    const flareX = W * 0.75;
    ctx.fillStyle = "rgba(255,200,150,0.03)";
    ctx.beginPath();
    ctx.arc(flareX, H * 0.3, 30, 0, Math.PI * 2);
    ctx.fill();
    
  } else if (currentLevel === 2) {
    // Single scan line
    const scanY = (frame * 2) % (H + 20) - 10;
    ctx.strokeStyle = "rgba(0,255,255,0.08)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, scanY);
    ctx.lineTo(W, scanY);
    ctx.stroke();
    
  } else if (currentLevel === 3) {
    // Very subtle vapor wisp
    ctx.fillStyle = "rgba(150,180,200,0.04)";
    const vaporX = (frame * 0.2) % W;
    const vaporY = H * 0.75 - Math.sin(frame * 0.02) * 10;
    ctx.beginPath();
    ctx.ellipse(vaporX, vaporY, 40, 15, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}


// ============================================================
// DRAWING - LEVEL
// ============================================================
function drawLevel() {
  ctx.save();
  ctx.translate(-Math.floor(camera.x), 0);
  
  // Ground - level themed
  for (const [gx, gy, gw] of level.ground) {
    if (gx + gw < camera.x - 32 || gx > camera.x + W + 32) continue;
    
    if (currentLevel === 1) {
      // THE INBOX - Email client style
      // Gray toolbar top
      ctx.fillStyle = "#c0c0c0";
      ctx.fillRect(gx, gy, gw, 4);
      // White email body
      ctx.fillStyle = "#f0f0f0";
      ctx.fillRect(gx, gy + 4, gw, 28);
      // Email row separators
      ctx.fillStyle = "#d8d8d8";
      for (let tx = gx; tx < gx + gw; tx += 32) {
        ctx.fillRect(tx, gy + 12, 30, 1);
        ctx.fillRect(tx, gy + 20, 30, 1);
      }
      // Blue unread dots
      ctx.fillStyle = "#0078d4";
      for (let tx = gx + 6; tx < gx + gw - 6; tx += 64) {
        ctx.beginPath();
        ctx.arc(tx, gy + 16, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if (currentLevel === 2) {
      // THE PERIMETER - TRON network style
      // Cyan glow line
      ctx.fillStyle = "#00ffff";
      ctx.fillRect(gx, gy, gw, 2);
      ctx.fillStyle = "#005555";
      ctx.fillRect(gx, gy + 2, gw, 2);
      // Dark tech body
      ctx.fillStyle = "#0a1520";
      ctx.fillRect(gx, gy + 4, gw, 28);
      // Vertical grid lines
      ctx.strokeStyle = "#003333";
      ctx.lineWidth = 1;
      for (let tx = gx; tx <= gx + gw; tx += 16) {
        ctx.beginPath();
        ctx.moveTo(tx, gy + 4);
        ctx.lineTo(tx, gy + 32);
        ctx.stroke();
      }
      // Status LEDs
      for (let tx = gx + 8; tx < gx + gw - 8; tx += 48) {
        ctx.fillStyle = (frame % 30 < 15) ? "#00ff00" : "#003300";
        ctx.fillRect(tx, gy + 10, 3, 3);
        ctx.fillStyle = (frame % 45 < 22) ? "#ff8800" : "#331100";
        ctx.fillRect(tx + 12, gy + 10, 3, 3);
      }
    } else {
      // DATACENTER - Server room floor
      // LEFT EDGE - bright vertical indicator
      ctx.fillStyle = "#ff4444";
      ctx.fillRect(gx, gy, 3, 32);
      ctx.fillStyle = "#ffdd33";
      ctx.fillRect(gx + 3, gy, 2, 32);
      // RIGHT EDGE - matching indicator
      ctx.fillStyle = "#ffdd33";
      ctx.fillRect(gx + gw - 5, gy, 2, 32);
      ctx.fillStyle = "#ff4444";
      ctx.fillRect(gx + gw - 3, gy, 3, 32);
      // Warning stripe top (between edges)
      for (let tx = gx + 5; tx < gx + gw - 5; tx += 16) {
        ctx.fillStyle = "#ffdd33";
        ctx.fillRect(tx, gy, 8, 4);
        ctx.fillStyle = "#333344";
        ctx.fillRect(tx + 8, gy, 8, 4);
      }
      // Raised floor body
      ctx.fillStyle = "#2a2a4a";
      ctx.fillRect(gx + 5, gy + 4, gw - 10, 28);
      // Floor tile pattern
      ctx.strokeStyle = "#4a4a6a";
      ctx.lineWidth = 1;
      for (let tx = gx + 8; tx < gx + gw - 8; tx += 24) {
        ctx.strokeRect(tx, gy + 7, 20, 20);
      }
      // Cooling vent slits
      ctx.fillStyle = "#1a1a2e";
      for (let tx = gx + 12; tx < gx + gw - 12; tx += 24) {
        ctx.fillRect(tx, gy + 10, 12, 2);
        ctx.fillRect(tx, gy + 16, 12, 2);
        ctx.fillRect(tx, gy + 22, 12, 2);
      }
    }
  }
  // Checkpoints - draw flag markers
  if (level.checkpoints) {
    for (let i = 0; i < level.checkpoints.length; i++) {
      const cp = level.checkpoints[i];
      const cpx = cp[0] - camera.x;
      const cpy = cp[1];
      if (cpx < -40 || cpx > W + 40) continue;
      // Flag pole
      ctx.fillStyle = '#666';
      ctx.fillRect(cpx - 2, cpy - 48, 4, 52);
      // Flag
      const reached = i <= checkpointReached;
      ctx.fillStyle = reached ? '#00ff88' : '#ff6644';
      ctx.beginPath();
      ctx.moveTo(cpx + 2, cpy - 48);
      ctx.lineTo(cpx + 22, cpy - 38);
      ctx.lineTo(cpx + 2, cpy - 28);
      ctx.closePath();
      ctx.fill();
      // Glow if reached
      if (reached) {
        ctx.globalAlpha = 0.3 + Math.sin(frame * 0.1) * 0.2;
        ctx.fillStyle = '#00ff88';
        ctx.beginPath();
        ctx.arc(cpx, cpy - 38, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
  }

  // Pipes - level themed
  for (const [px, py, ph] of level.pipes) {
    if (px < camera.x - 40 || px > camera.x + W + 40) continue;
    
    if (currentLevel === 1) {
      // THE INBOX - Monitor/PC tower
      // Monitor body
      ctx.fillStyle = "#2a2a2a";
      ctx.fillRect(px + 2, py, 28, ph - 8);
      // Screen
      ctx.fillStyle = "#3a5a8a";
      ctx.fillRect(px + 5, py + 4, 22, ph - 16);
      // Screen glow
      ctx.fillStyle = "#4a7aba";
      ctx.fillRect(px + 7, py + 6, 18, ph - 20);
      // Monitor base
      ctx.fillStyle = "#3a3a3a";
      ctx.fillRect(px + 8, py + ph - 8, 16, 4);
      ctx.fillRect(px + 4, py + ph - 4, 24, 4);
      // Top bezel
      ctx.fillStyle = "#4a4a4a";
      ctx.fillRect(px, py - 8, 32, 10);
    } else if (currentLevel === 2) {
      // THE PERIMETER - Network rack/router
      ctx.fillStyle = "#1a2a3a";
      ctx.fillRect(px + 2, py, 28, ph);
      // Rack slots
      ctx.fillStyle = "#0a1520";
      for (let sy = py + 4; sy < py + ph - 4; sy += 8) {
        ctx.fillRect(px + 4, sy, 24, 6);
      }
      // Port LEDs
      for (let sy = py + 6; sy < py + ph - 6; sy += 8) {
        ctx.fillStyle = (frame + sy) % 30 < 15 ? "#00ff00" : "#003300";
        ctx.fillRect(px + 6, sy, 3, 2);
        ctx.fillStyle = (frame + sy + 10) % 40 < 20 ? "#00ffff" : "#003333";
        ctx.fillRect(px + 12, sy, 3, 2);
      }
      // Rack top
      ctx.fillStyle = "#2a3a4a";
      ctx.fillRect(px, py - 8, 32, 10);
      ctx.fillStyle = "#00cccc";
      ctx.fillRect(px, py - 8, 32, 2);
    } else {
      // DATACENTER - Server tower
      ctx.fillStyle = "#1a1a2e";
      ctx.fillRect(px + 2, py, 28, ph);
      // Drive bays
      ctx.fillStyle = "#0a0a1a";
      for (let sy = py + 4; sy < py + ph - 4; sy += 10) {
        ctx.fillRect(px + 4, sy, 24, 8);
      }
      // Status lights
      for (let sy = py + 6; sy < py + ph - 6; sy += 10) {
        ctx.fillStyle = "#00ff00";
        ctx.fillRect(px + 6, sy, 2, 2);
        ctx.fillStyle = (frame + sy) % 20 < 10 ? "#ff8800" : "#331100";
        ctx.fillRect(px + 10, sy, 2, 2);
        ctx.fillStyle = "#ff0000";
        ctx.fillRect(px + 14, sy, 2, 2);
      }
      // Top with warning stripe
      for (let sx = px; sx < px + 32; sx += 8) {
        ctx.fillStyle = "#ffcc00";
        ctx.fillRect(sx, py - 8, 4, 10);
        ctx.fillStyle = "#222222";
        ctx.fillRect(sx + 4, py - 8, 4, 10);
      }
    }
  }
  // Platforms - level themed
  for (const [px, py, pw] of level.platforms) {
    if (px + pw < camera.x - 16 || px > camera.x + W + 16) continue;
    
    if (currentLevel === 1) {
      // THE INBOX - Folder tab style
      ctx.fillStyle = "#e8e8e8";
      ctx.fillRect(px, py, pw, 8);
      // Tab top highlight
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(px + 1, py + 1, pw - 2, 2);
      // Tab shadow
      ctx.fillStyle = "#c0c0c0";
      ctx.fillRect(px, py + 6, pw, 2);
      // Folder icon
      if (pw >= 32) {
        ctx.fillStyle = "#f4c542";
        ctx.fillRect(px + 4, py + 2, 8, 4);
        ctx.fillRect(px + 2, py + 3, 12, 3);
      }
    } else if (currentLevel === 2) {
      // THE PERIMETER - Network switch port
      ctx.fillStyle = "#1a2a3a";
      ctx.fillRect(px, py, pw, 8);
      // Port holes
      ctx.fillStyle = "#0a1520";
      for (let sx = px + 4; sx < px + pw - 4; sx += 10) {
        ctx.fillRect(sx, py + 2, 6, 4);
      }
      // Activity LEDs
      for (let sx = px + 6; sx < px + pw - 6; sx += 10) {
        ctx.fillStyle = (frame + sx) % 40 < 20 ? "#00ff00" : "#002200";
        ctx.fillRect(sx, py + 3, 2, 2);
      }
      // Cyan edge glow
      ctx.fillStyle = "#00cccc";
      ctx.fillRect(px, py, pw, 1);
    } else {
      // DATACENTER - Server blade slot (QA FIX: higher contrast)
      ctx.fillStyle = "#4a4a7a";  // Brighter base color
      ctx.fillRect(px, py, pw, 8);
      // Bright edge highlight for visibility
      ctx.fillStyle = "#8080c0";
      ctx.fillRect(px, py, pw, 2);
      // Blade slots
      ctx.fillStyle = "#2a2a4a";
      for (let sx = px + 2; sx < px + pw - 2; sx += 12) {
        ctx.fillRect(sx, py + 2, 10, 5);
      }
      // Status indicators
      for (let sx = px + 4; sx < px + pw - 4; sx += 12) {
        ctx.fillStyle = (frame + sx) % 50 < 25 ? "#ff5555" : "#550000";
        ctx.fillRect(sx, py + 3, 2, 2);
        ctx.fillStyle = "#44ff44";
        ctx.fillRect(sx + 4, py + 3, 2, 2);
      }
      // Yellow edge warning
      ctx.fillStyle = "#ccaa00";
      ctx.fillRect(px, py, pw, 1);
    }
  }
  // Blocks - level themed
  for (const b of blocks) {
    if (b.type === -1) continue;
    if (b.x < camera.x - 20 || b.x > camera.x + W + 20) continue;
    
    const bounce = b.bounceTimer > 0 ? Math.sin(b.bounceTimer * 0.5) * 4 : 0;
    if (b.bounceTimer > 0) b.bounceTimer--;
    const by = b.y - bounce;
    
    if (b.type === 0) {
      // Brick block - level themed
      if (currentLevel === 1) {
        // THE INBOX - File folder brick
        ctx.fillStyle = "#f4c542";
        ctx.fillRect(b.x, by, 16, 16);
        ctx.fillStyle = "#d4a522";
        ctx.fillRect(b.x + 1, by + 4, 14, 11);
        ctx.fillStyle = "#e4b532";
        ctx.fillRect(b.x + 2, by + 1, 8, 4);
      } else if (currentLevel === 2) {
        // THE PERIMETER - Network module
        ctx.fillStyle = "#1a2a3a";
        ctx.fillRect(b.x, by, 16, 16);
        ctx.fillStyle = "#0a1520";
        ctx.fillRect(b.x + 2, by + 2, 5, 5);
        ctx.fillRect(b.x + 9, by + 2, 5, 5);
        ctx.fillRect(b.x + 2, by + 9, 5, 5);
        ctx.fillRect(b.x + 9, by + 9, 5, 5);
        ctx.fillStyle = "#00cccc";
        ctx.fillRect(b.x, by, 16, 1);
      } else {
        // DATACENTER - Server brick
        ctx.fillStyle = "#2a2a4a";
        ctx.fillRect(b.x, by, 16, 16);
        ctx.fillStyle = "#1a1a2e";
        ctx.fillRect(b.x + 1, by + 2, 14, 5);
        ctx.fillRect(b.x + 1, by + 9, 14, 5);
        ctx.fillStyle = "#00ff00";
        ctx.fillRect(b.x + 2, by + 3, 2, 2);
        ctx.fillRect(b.x + 2, by + 10, 2, 2);
      }
    } else if (b.type === 1) {
      // Question block - level themed
      if (currentLevel === 1) {
        // THE INBOX - Inbox item
        ctx.fillStyle = "#0078d4";
        ctx.fillRect(b.x, by, 16, 16);
        ctx.fillStyle = "#005a9e";
        ctx.fillRect(b.x + 2, by + 2, 12, 12);
        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 12px sans-serif";
        ctx.fillText("?", b.x + 4, by + 12);
        if (frame % 30 < 15) {
          ctx.fillStyle = "rgba(255,255,255,0.3)";
          ctx.fillRect(b.x + 2, by + 2, 4, 8);
        }
      } else if (currentLevel === 2) {
        // THE PERIMETER - Data packet
        ctx.fillStyle = "#00aaaa";
        ctx.fillRect(b.x, by, 16, 16);
        ctx.fillStyle = "#008888";
        ctx.fillRect(b.x + 2, by + 2, 12, 12);
        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 12px sans-serif";
        ctx.fillText("?", b.x + 4, by + 12);
        // Glow effect
        if (frame % 30 < 15) {
          ctx.fillStyle = "rgba(0,255,255,0.3)";
          ctx.fillRect(b.x + 2, by + 2, 4, 8);
        }
      } else {
        // DATACENTER - Secure container
        ctx.fillStyle = "#8844aa";
        ctx.fillRect(b.x, by, 16, 16);
        ctx.fillStyle = "#663388";
        ctx.fillRect(b.x + 2, by + 2, 12, 12);
        ctx.fillStyle = "#ffcc00";
        ctx.font = "bold 12px sans-serif";
        ctx.fillText("?", b.x + 4, by + 12);
        if (frame % 30 < 15) {
          ctx.fillStyle = "rgba(255,204,0,0.3)";
          ctx.fillRect(b.x + 2, by + 2, 4, 8);
        }
      }
    } else if (b.type === 2) {
      // Used block - level themed
      if (currentLevel === 1) {
        ctx.fillStyle = "#c0c0c0";
        ctx.fillRect(b.x, by, 16, 16);
        ctx.fillStyle = "#a0a0a0";
        ctx.fillRect(b.x + 2, by + 2, 12, 12);
      } else if (currentLevel === 2) {
        ctx.fillStyle = "#1a2a3a";
        ctx.fillRect(b.x, by, 16, 16);
        ctx.fillStyle = "#0a1520";
        ctx.fillRect(b.x + 2, by + 2, 12, 12);
      } else {
        ctx.fillStyle = "#2a2a3a";
        ctx.fillRect(b.x, by, 16, 16);
        ctx.fillStyle = "#1a1a2a";
        ctx.fillRect(b.x + 2, by + 2, 12, 12);
      }
    }
  }
  // Tokens (DUO MFA)
  for (const t of tokens) {
    if (t.collected) continue;
    if (t.x < camera.x - 20 || t.x > camera.x + W + 20) continue;
    t.anim += 0.15;
    drawDuoToken(t.x, t.y, t.anim);
  }
  
  // Powerups (ISE Shield)
  for (const pu of powerups) {
    drawShieldPowerup(pu.x, pu.y, pu.timer);
  }
  
  // Level-Themed Exit Goal - Large Gateway with Laser Animation
  const exitX = level.width - 80;
  const portalScreenX = exitX; // World coords due to ctx.translate
  if (exitX > camera.x - 100 && exitX < camera.x + W + 100) {
    const allTokens = collectedTokens >= tokens.length;
    const pulse = Math.sin(frame * 0.1) * 0.3 + 0.7;
    const pulse2 = Math.sin(frame * 0.08) * 0.4 + 0.6;
    const bobY = Math.sin(frame * 0.05) * 2;
    
    const goalColor = currentLevel === 1 ? BRAND.duoGreen : 
                      currentLevel === 2 ? BRAND.ciscoBlue : "#9b59b6";
    const lockedColor = "#cc0000";
    
    // Track when player first sees exit with all tokens
    if (!exitSeen && exitX < camera.x + W + 50) {
      exitSeen = true;
      if (allTokens && exitLasersActive) {
        // Start unlock animation
        exitUnlockTimer = 1; SFX.powerup();
      }
    }
    
    // Update unlock animation timer
    if (exitUnlockTimer > 0 && exitUnlockTimer < 90) {
      exitUnlockTimer++;
      if (exitUnlockTimer >= 90) {
        exitLasersActive = false;
      }
    }
    
    // If returned with all tokens after seeing it locked
    if (exitSeen && allTokens && exitLasersActive && exitUnlockTimer === 0) {
      exitUnlockTimer = 1; SFX.powerup();
    }
    
    const lasersOff = !exitLasersActive;
    const activeColor = lasersOff ? goalColor : lockedColor;
    
    // LARGE SECURITY GATEWAY
    const gateX = portalScreenX - 20;
    const gateW = 88;
    const gateH = 120;
    
    // Background glow (only when fully unlocked)
    if (lasersOff) {
      ctx.fillStyle = goalColor;
      ctx.globalAlpha = 0.3 * pulse;
      ctx.beginPath();
      ctx.ellipse(gateX + gateW/2, 140, 70, 80, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    
    // Ground glow
    ctx.fillStyle = activeColor;
    ctx.globalAlpha = 0.6 * pulse;
    ctx.beginPath();
    ctx.ellipse(gateX + gateW/2, 190, 55, 14, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // Left pillar
    ctx.fillStyle = "#2d3748";
    ctx.fillRect(gateX, 72, 20, 120);
    ctx.fillStyle = "#1a202c";
    ctx.fillRect(gateX + 3, 75, 14, 114);
    
    // Right pillar
    ctx.fillStyle = "#2d3748";
    ctx.fillRect(gateX + gateW - 20, 72, 20, 120);
    ctx.fillStyle = "#1a202c";
    ctx.fillRect(gateX + gateW - 17, 75, 14, 114);
    
    // Top archway beam
    ctx.fillStyle = "#2d3748";
    ctx.fillRect(gateX, 60 + bobY, gateW, 20);
    ctx.fillStyle = "#3d4a5c";
    ctx.fillRect(gateX + 4, 64 + bobY, gateW - 8, 12);
    
    // Level text on beam
    ctx.fillStyle = "#fff";
    ctx.font = "bold 10px monospace";
    ctx.textAlign = "center";
    const levelText = currentLevel === 1 ? "INBOX" : currentLevel === 2 ? "PERIMETER" : "VAULT";
    ctx.fillText(levelText, gateX + gateW/2, 73 + bobY);
    
    // LASER BARRIER SYSTEM (6 lasers)
    const numLasers = 6;
    const laserSpacing = 16;
    const laserStartY = 82;
    
    for (let i = 0; i < numLasers; i++) {
      const laserY = laserStartY + i * laserSpacing;
      
      // Calculate if this laser should be on
      let laserOn = true;
      if (exitUnlockTimer > 0) {
        // Lasers turn off sequentially from top to bottom
        const turnOffTime = 15 + i * 12; // Each laser turns off 25 frames apart
        if (exitUnlockTimer >= turnOffTime) {
          laserOn = false;
        }
      }
      if (!exitLasersActive) {
        laserOn = false;
      }
      
      if (laserOn) {
        // Laser emitters on pillars
        ctx.fillStyle = "#ff0000";
        ctx.beginPath();
        ctx.arc(gateX + 17, laserY + 4, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(gateX + gateW - 17, laserY + 4, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Laser beam (animated flicker)
        const flicker = 0.7 + Math.sin(frame * 0.5 + i * 2) * 0.3;
        ctx.strokeStyle = "#ff0000";
        ctx.globalAlpha = flicker;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(gateX + 21, laserY + 4);
        ctx.lineTo(gateX + gateW - 21, laserY + 4);
        ctx.stroke();
        
        // Laser glow
        ctx.strokeStyle = "#ff6666";
        ctx.globalAlpha = flicker * 0.5;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(gateX + 21, laserY + 4);
        ctx.lineTo(gateX + gateW - 21, laserY + 4);
        ctx.stroke();
        ctx.globalAlpha = 1;
      } else {
        // Deactivated emitter (dark)
        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.arc(gateX + 17, laserY + 4, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(gateX + gateW - 17, laserY + 4, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // Portal energy when fully unlocked
    if (lasersOff) {
      for (let i = 0; i < 6; i++) {
        const ey = 85 + i * 16;
        const ew = 40 - Math.abs(ey - 130) * 0.2;
        ctx.fillStyle = goalColor;
        ctx.globalAlpha = 0.4 + Math.sin(frame * 0.1 + i * 0.5) * 0.2;
        ctx.fillRect(gateX + gateW/2 - ew/2, ey, ew, 12);
      }
      ctx.globalAlpha = 1;
      
      // Rising particles
      for (let i = 0; i < 8; i++) {
        const py = 185 - ((frame * 2 + i * 23) % 110);
        const px = gateX + gateW/2 + Math.sin(frame * 0.04 + i * 1.2) * 20;
        ctx.fillStyle = i % 2 === 0 ? "#fff" : goalColor;
        ctx.globalAlpha = 0.9 - (185 - py) / 130;
        ctx.fillRect(px - 2, py, 4, 4);
      }
      ctx.globalAlpha = 1;
      
      // "CLEAR" text
      ctx.fillStyle = goalColor;
      ctx.font = "bold 12px monospace";
      ctx.fillText("CLEAR!", gateX + gateW/2, 145);
    } else if (exitUnlockTimer > 0) {
      // During unlock animation
      ctx.fillStyle = "#ffff00";
      ctx.font = "bold 11px monospace";
      ctx.fillText("UNLOCKING", gateX + gateW/2, 145);
    } else {
      // Locked text
      ctx.fillStyle = lockedColor;
      ctx.font = "bold 11px monospace";
      ctx.fillText("LOCKED", gateX + gateW/2, 145);
    }
    
    // Status lights on pillars (outside laser area)
    for (let i = 0; i < 2; i++) {
      ctx.fillStyle = activeColor;
      ctx.globalAlpha = pulse2;
      ctx.beginPath();
      ctx.arc(gateX + 10, 85 + i * 80, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(gateX + gateW - 10, 85 + i * 80, 4, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    
    // Top circle emblem
    ctx.fillStyle = activeColor;
    ctx.beginPath();
    ctx.arc(gateX + gateW/2, 48 + bobY, 16, 0, Math.PI * 2);
    ctx.fill();
    
    // Emblem icon
    if (lasersOff) {
      // Big checkmark
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(gateX + gateW/2 - 8, 48 + bobY);
      ctx.lineTo(gateX + gateW/2 - 2, 54 + bobY);
      ctx.lineTo(gateX + gateW/2 + 10, 40 + bobY);
      ctx.stroke();
    } else {
      // X mark
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(gateX + gateW/2 - 7, 41 + bobY);
      ctx.lineTo(gateX + gateW/2 + 7, 55 + bobY);
      ctx.moveTo(gateX + gateW/2 + 7, 41 + bobY);
      ctx.lineTo(gateX + gateW/2 - 7, 55 + bobY);
      ctx.stroke();
    }
    
    // Token counter below
    ctx.fillStyle = "#fff";
    ctx.font = "bold 10px monospace";
    ctx.fillText(collectedTokens + "/" + tokens.length, gateX + gateW/2, 205);
    ctx.textAlign = "left";
  }
  // Enemies
  for (const e of enemies) {
    if (!e.alive) continue;
    if (e.x < camera.x - 20 || e.x > camera.x + W + 20) continue;
    
    const squash = e.stompTimer > 0 ? 0.3 : 1;
    
    ctx.save();
    ctx.translate(e.vx > 0 ? e.x + 16 : e.x, e.y);
    ctx.scale(e.vx > 0 ? -1 : 1, 1);
    if (e.vx > 0) ctx.translate(-16, 0);
    
    if (e.type === 0) {
      drawPhishingEmail(0, 0, e.animTimer, squash);
    } else if (e.type === 1) {
      drawDataBreachWorm(0, 0, e.animTimer, squash, e.vx > 0);
    } else if (e.type === 2) {
      drawHacker(0, 0, e.animTimer, e.state, squash);
    } else if (e.type === 3) {
      drawCredentialStealer(0, 0, e.animTimer, e.state, squash);
    } else if (e.type === 4) {
      drawMaliciousAttachment(0, 0, e.animTimer, squash);
    } else if (e.type === 5) {
      drawRogueAP(0, 0, e.animTimer, e.dangerRadius, squash);
    } else if (e.type === 6) {
      drawPacketSniffer(0, 0, e.animTimer, squash);
    } else if (e.type === 7) {
      drawRansomwareLock(0, 0, e.animTimer, squash);
    } else if (e.type === 8) {
      drawDataExfiltrator(0, 0, e.animTimer, squash);
    }
    
    ctx.restore();
  }
  
// Player - CDW Tech Specialist (Enhanced)
  if (player.invincible === 0 || Math.floor(frame / 3) % 2 === 0) {
    const ph = player.big ? 28 : 20;
    const bobY = player.grounded && Math.abs(player.vx) < 0.1 ? Math.sin(frame * 0.1) * 0.5 : 0;
    
    ctx.save();
    ctx.translate(player.x + player.width / 2, player.y + ph + bobY);
    ctx.scale(player.facing * player.squashX, player.squashY);
    ctx.translate(-player.width / 2, -ph);
    
    const bodyColor = player.invincible > 0 ? "#ff9090" : BRAND.cdwRed;
    const running = player.grounded && Math.abs(player.vx) > 0.5;
    const airborne = !player.grounded;
    
    // Shadow
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.beginPath();
    ctx.ellipse(6, ph + 2, 7, 2.5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Legs
    ctx.fillStyle = "#2a3a4a";
    if (running) {
      const legPhase = player.animTimer * 0.8;
      const legOff = Math.sin(legPhase) * 4;
      ctx.fillRect(2, ph - 5, 4, 5 + legOff);
      ctx.fillRect(7, ph - 5, 4, 5 - legOff);
      ctx.fillStyle = "#1a1a2a";
      ctx.fillRect(1, ph - 1 + Math.max(0, legOff), 5, 2);
      ctx.fillRect(6, ph - 1 + Math.max(0, -legOff), 5, 2);
    } else if (airborne) {
      ctx.fillRect(1, ph - 6, 4, 5);
      ctx.fillRect(8, ph - 4, 4, 4);
      ctx.fillStyle = "#1a1a2a";
      ctx.fillRect(0, ph - 2, 5, 2);
      ctx.fillRect(8, ph - 1, 5, 2);
    } else {
      ctx.fillRect(2, ph - 5, 4, 5);
      ctx.fillRect(7, ph - 5, 4, 5);
      ctx.fillStyle = "#1a1a2a";
      ctx.fillRect(1, ph - 1, 5, 2);
      ctx.fillRect(6, ph - 1, 5, 2);
    }
    
    // Body
    ctx.fillStyle = bodyColor;
    ctx.fillRect(1, ph - 13, 11, 9);
    
    // Tool belt
    ctx.fillStyle = "#3a3a4a";
    ctx.fillRect(1, ph - 5, 11, 2);
    ctx.fillStyle = BRAND.ciscoBlue;
    ctx.fillRect(5, ph - 5, 3, 2);
    
    // Arms
    ctx.fillStyle = bodyColor;
    if (running) {
      const armSwing = Math.sin(player.animTimer * 0.8) * 3;
      ctx.fillRect(-1, ph - 12 - armSwing, 3, 6);
      ctx.fillRect(11, ph - 12 + armSwing, 3, 6);
    } else if (airborne) {
      ctx.fillRect(-2, ph - 15, 3, 5);
      ctx.fillRect(12, ph - 15, 3, 5);
    } else {
      ctx.fillRect(-1, ph - 12, 3, 6);
      ctx.fillRect(11, ph - 12, 3, 6);
    }
    
    // Head (rounder)
    ctx.fillStyle = "#ffddbb";
    ctx.beginPath();
    ctx.ellipse(6, ph - 17, 5, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Hair
    ctx.fillStyle = "#4a3020";
    ctx.fillRect(1, ph - 23, 10, 4);
    ctx.fillRect(2, ph - 24, 8, 2);
    ctx.fillRect(3, ph - 25, 4, 2);
    
    // Eyes
    const blinkFrame = frame % 180;
    const isBlinking = blinkFrame > 175;
    ctx.fillStyle = "#fff";
    ctx.fillRect(3, ph - 18, 3, isBlinking ? 1 : 2);
    ctx.fillRect(7, ph - 18, 3, isBlinking ? 1 : 2);
    if (!isBlinking) {
      ctx.fillStyle = "#2a4a6a";
      const pupilOff = player.facing > 0 ? 1 : 0;
      ctx.fillRect(4 + pupilOff, ph - 17, 1, 1);
      ctx.fillRect(8 + pupilOff, ph - 17, 1, 1);
    }
    
    // Eyebrows
    ctx.fillStyle = "#3a2515";
    if (airborne) {
      ctx.fillRect(3, ph - 20, 3, 1);
      ctx.fillRect(7, ph - 20, 3, 1);
    } else {
      ctx.fillRect(3, ph - 19, 3, 1);
      ctx.fillRect(7, ph - 19, 3, 1);
    }
    
    // Mouth
    ctx.fillStyle = "#aa6655";
    if (airborne) {
      ctx.fillRect(5, ph - 14, 3, 2);
    } else if (running) {
      ctx.fillRect(5, ph - 14, 3, 1);
    } else {
      ctx.fillRect(5, ph - 14, 2, 1);
    }
    
    // Headset
    ctx.fillStyle = "#2a2a3a";
    ctx.fillRect(-1, ph - 18, 2, 3);
    ctx.fillStyle = BRAND.ciscoBlue;
    ctx.fillRect(-1, ph - 17, 1, 1);
    
    // Shield bubble effect (level-themed, no avatar change)
    if (player.big) {
      const shield = getShieldInfo();
      const pulse = Math.sin(frame * 0.15) * 0.3 + 0.7;
      const pulse2 = Math.sin(frame * 0.1) * 0.2 + 0.4;
      
      // Outer glow
      ctx.strokeStyle = shield.color;
      ctx.globalAlpha = pulse * 0.8;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(6, ph / 2, 11, ph / 2 + 4, 0, 0, Math.PI * 2);
      ctx.stroke();
      
      // Inner shield
      ctx.globalAlpha = pulse2;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.ellipse(6, ph / 2, 9, ph / 2 + 2, 0, 0, Math.PI * 2);
      ctx.stroke();
      
      // Shield fill (very transparent)
      ctx.fillStyle = shield.color;
      ctx.globalAlpha = 0.15;
      ctx.beginPath();
      ctx.ellipse(6, ph / 2, 9, ph / 2 + 2, 0, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.globalAlpha = 1;
    }
    
    ctx.restore();
  }

  // Particles
  for (const p of particles) {
    ctx.globalAlpha = Math.min(1, p.life / 15);
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1;
  
  // Floating texts
  ctx.font = 'bold 8px sans-serif';
  ctx.textAlign = 'left';
  for (const ft of floatingTexts) {
    ctx.globalAlpha = Math.min(1, ft.timer / 20);
    ctx.fillStyle = '#fff';
    ctx.fillText(ft.text, ft.x, ft.y);
  }
  ctx.globalAlpha = 1;
  
  ctx.restore();
}

// ============================================================
// DRAWING - HUD
// ============================================================
function drawHUD() {
  // Level indicator (top center)
  ctx.fillStyle = "#fff";
  ctx.font = "bold 8px monospace";
  ctx.textAlign = "center";
  ctx.fillText("ZONE " + currentLevel + ": " + LEVEL_INFO[currentLevel].name, W/2, 10);
  ctx.textAlign = "left";
  
  // Hearts for lives (top left)
  for (let i = 0; i < lives; i++) {
    drawHeart(12 + i * 14, 22, 10);
  }
  
  // MFA Tokens collected
  const pct = Math.floor(collectedTokens / tokens.length * 100);
  // MFA token counter (turns bright when complete)
  const allTokens = collectedTokens >= tokens.length;
  ctx.fillStyle = allTokens ? "#00ff88" : BRAND.duoGreen;
  ctx.font = "bold 10px sans-serif";
  ctx.fillText("MFA: " + collectedTokens + "/" + tokens.length, 10, 40);
  
  // Exit status indicator
  if (!allTokens) {
    ctx.fillStyle = "#ff6666";
    ctx.font = "8px sans-serif";
    ctx.fillText("🔒 COLLECT ALL → EXIT", 10, 50);
  } else {
    ctx.fillStyle = "#00ff88";
    ctx.font = "bold 7px sans-serif";
    ctx.fillText("✓ EXIT UNLOCKED!", 10, 50);
  }
  
  // Logos (smaller, top right)
  drawCDWLogo(W - 55, 16, 0.5);
  ctx.fillStyle = "#666";
  ctx.font = "8px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("+", W - 35, 18);
  drawCiscoLogo(W - 15, 16, 0.5);
  ctx.textAlign = "left";
  
  // P-Meter (bottom left)
  const pFill = player.pMeter / player.pMeterMax;
  ctx.fillStyle = "#333";
  ctx.fillRect(10, H - 18, 50, 6);
  ctx.fillStyle = pFill >= 1 ? "#ff0" : BRAND.ciscoBlue;
  ctx.fillRect(11, H - 17, pFill * 48, 4);
  ctx.fillStyle = "#888";
  ctx.font = "6px sans-serif";
  ctx.fillText("RUN", 10, H - 22);
  
  // Shield status
  if (player.big) {
    ctx.fillStyle = getShieldInfo().color;
    ctx.font = "bold 8px sans-serif";
    ctx.textAlign = "right";
    ctx.fillText(getShieldInfo().fullName + " ACTIVE", W - 10, H - 18);
    ctx.textAlign = "left";
  }
  
  // Progress bar (bottom center)
  const prog = Math.min(camera.x / Math.max(level.width - W, 1), 1);
  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fillRect(W/2 - 50, H - 10, 100, 6);
  ctx.fillStyle = BRAND.duoGreen;
  ctx.fillRect(W/2 - 49, H - 9, prog * 98, 4);
  ctx.fillStyle = "#fff";
  ctx.fillRect(W/2 - 50 + prog * 98, H - 11, 3, 8);
}

// Draw a heart shape
function drawHeart(x, y, size) {
  ctx.fillStyle = BRAND.cdwRed;
  ctx.beginPath();
  const s = size / 10;
  ctx.moveTo(x, y + 2*s);
  ctx.bezierCurveTo(x, y, x - 5*s, y, x - 5*s, y + 3*s);
  ctx.bezierCurveTo(x - 5*s, y + 5*s, x, y + 7*s, x, y + 9*s);
  ctx.bezierCurveTo(x, y + 7*s, x + 5*s, y + 5*s, x + 5*s, y + 3*s);
  ctx.bezierCurveTo(x + 5*s, y, x, y, x, y + 2*s);
  ctx.fill();
}

// ============================================================
// TITLE SCREEN
// ============================================================

// ============================================================
// INTRO CRAWL (3 screens)
// ============================================================
function drawIntro() {
  // Dark background
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, "#050510");
  grad.addColorStop(0.5, "#0a1020");
  grad.addColorStop(1, "#050510");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
  
  // Scanlines
  ctx.fillStyle = "rgba(0,0,0,0.15)";
  for (let i = 0; i < H; i += 2) {
    ctx.fillRect(0, i, W, 1);
  }
  
  const screen = INTRO_SCREENS[introScreen];
  if (!screen) return;
  
  // Text
  ctx.fillStyle = "#00ff88";
  ctx.font = "bold 10px monospace";
  ctx.textAlign = "center";
  
  let y = 70;
  for (const line of screen.lines) {
    if (line === "") {
      y += 12;
    } else {
      ctx.fillText(line, W/2, y);
      y += 18;
    }
  }
  
  // Screen indicator
  ctx.fillStyle = "#446";
  ctx.font = "8px monospace";
  ctx.fillText((introScreen + 1) + " / 3", W/2, H - 40);
  
  // Prompt
  if (frame % 50 < 30) {
    ctx.fillStyle = "#888";
    ctx.font = "9px monospace";
    ctx.fillText("PRESS A TO START", W/2, H - 20);
  }
}

// ============================================================
// LEVEL INTRO CARD
// ============================================================
function drawLevelIntro() {
  // Background
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, "#0a1025");
  grad.addColorStop(1, "#051015");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
  
  const info = LEVEL_INFO[currentLevel];
  if (!info) return;
  
  // Zone header
  ctx.fillStyle = getShieldInfo().color;
  ctx.font = "bold 9px monospace";
  ctx.textAlign = "center";
  ctx.fillText(info.zone + ": " + info.name, W/2, 55);
  
  // Divider
  ctx.strokeStyle = BRAND.ciscoBlue;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(40, 68);
  ctx.lineTo(W - 40, 68);
  ctx.stroke();
  
  // Challenge text
  ctx.fillStyle = "#fff";
  ctx.font = "9px monospace";
  ctx.fillText(info.challenge, W/2, 95);
  ctx.fillText(info.solution, W/2, 110);
  
  // Activating message
  ctx.fillStyle = BRAND.duoGreen;
  ctx.font = "bold 11px monospace";
  const activatingLines = info.activating.split("\\n");
  let ay = 145;
  for (const line of activatingLines) {
    ctx.fillText(line, W/2, ay);
    ay += 16;
  }
  
  // Press A to Start prompt
  if (frame % 50 < 35) {
    ctx.fillStyle = BRAND.duoGreen;
    ctx.font = "bold 9px monospace";
    ctx.fillText("PRESS A TO START", W/2, H - 22);
  }
}

// ============================================================
// LEVEL COMPLETE SCREEN
// ============================================================
function drawLevelComplete() {
  // Green-tinted background
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, "#0a2015");
  grad.addColorStop(1, "#051510");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
  
  const info = LEVEL_INFO[currentLevel];
  if (!info) return;
  
  // Checkmark
  ctx.fillStyle = BRAND.duoGreen;
  ctx.font = "bold 32px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("✓", W/2, 55);
  
  // Title
  ctx.fillStyle = BRAND.duoGreen;
  ctx.font = "bold 14px monospace";
  ctx.fillText(info.completeTitle, W/2, 85);
  
  // Status lines
  ctx.fillStyle = "#fff";
  ctx.font = "9px monospace";
  let ly = 115;
  for (const line of info.completeLines) {
    ctx.fillText(line, W/2, ly);
    ly += 16;
  }
  
  // Footer
  ctx.fillStyle = getShieldInfo().color;
  ctx.font = "bold 11px monospace";
  ctx.fillText(info.completeFooter, W/2, 165);
  
  // Press A to Start prompt
  if (frame % 50 < 35) {
    ctx.fillStyle = getShieldInfo().color;
    ctx.font = "bold 9px monospace";
    ctx.textAlign = "center";
    ctx.fillText("PRESS A TO START", W/2, H - 22);
  }
}

// ============================================================
// ============================================================
// DRAWING - ENEMY PREVIEW CARD
// ============================================================
function drawEnemyPreview() {
  const levelColors = { 1: "#4488ff", 2: "#44ff88", 3: "#ff4488" };
  const color = levelColors[currentLevel] || "#fff";
  
  // Background
  ctx.fillStyle = "#111";
  ctx.fillRect(0, 0, W, H);
  
  // Header
  ctx.fillStyle = color;
  ctx.font = "bold 12px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("THREATS DETECTED", W/2, 18);
  
  // Divider line
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(16, 26);
  ctx.lineTo(W - 16, 26);
  ctx.stroke();
  
  // Get enemies for this level
  const enemyTypes = levelEnemyTypes[currentLevel] || [];
  const startY = 32;
  const rowHeight = 46;
  
  // Draw each enemy row
  enemyTypes.forEach((type, i) => {
    const meta = enemyMeta[type];
    if (!meta) return;
    
    const y = startY + i * rowHeight;
    
    // Draw sprite at native size
    ctx.save();
    ctx.translate(24, y + 10);
    
    const anim = frame * 0.1;
    if (type === 0) drawPhishingEmail(0, 0, anim, 1);
    else if (type === 1) drawDataBreachWorm(-4, 0, anim, 1, false);
    else if (type === 2) drawHacker(0, 0, anim, "patrol", 1);
    else if (type === 3) drawCredentialStealer(0, 0, anim, "patrol", 1);
    else if (type === 4) drawMaliciousAttachment(-8, 0, anim, 1);
    else if (type === 5) drawRogueAP(0, 0, anim, 0, 1);
    else if (type === 6) drawPacketSniffer(0, 0, anim, 1);
    else if (type === 7) drawRansomwareLock(0, 0, anim, 1);
    else if (type === 8) drawDataExfiltrator(0, 0, anim, 1);
    
    ctx.restore();
    
    // Enemy name - with shadow for readability
    ctx.font = "bold 10px sans-serif";
    ctx.textAlign = "left";
    // Shadow
    ctx.fillStyle = "#000";
    ctx.fillText(meta.name, 50, y + 12);
    // Main text
    ctx.fillStyle = "#fff";
    ctx.fillText(meta.name, 48, y + 12);
    
    // Description - smart wrap if too long
    ctx.font = "9px sans-serif";
    const maxW = W - 56;  // Available width
    const descW = ctx.measureText(meta.desc).width;
    
    if (descW > maxW) {
      // Wrap: find midpoint word break
      const words = meta.desc.split(" ");
      let line1 = "", line2 = "";
      for (let w of words) {
        if (ctx.measureText(line1 + w).width < maxW) {
          line1 += (line1 ? " " : "") + w;
        } else {
          line2 += (line2 ? " " : "") + w;
        }
      }
      // Line 1
      ctx.fillStyle = "#000";
      ctx.fillText(line1, 50, y + 24);
      ctx.fillStyle = "#ddd";
      ctx.fillText(line1, 48, y + 24);
      // Line 2
      ctx.fillStyle = "#000";
      ctx.fillText(line2, 50, y + 34);
      ctx.fillStyle = "#ddd";
      ctx.fillText(line2, 48, y + 34);
    } else {
      // Single line
      ctx.fillStyle = "#000";
      ctx.fillText(meta.desc, 50, y + 26);
      ctx.fillStyle = "#ddd";
      ctx.fillText(meta.desc, 48, y + 26);
    }
  });
  
  // Press A prompt (blinking)
  if (Math.floor(frame / 30) % 2 === 0) {
    ctx.fillStyle = color;
    ctx.font = "bold 12px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("PRESS A TO START", W/2, H - 12);
  }
}

// VICTORY SCREEN (with Clearance Code)
// ============================================================
function drawVictory() {
  // Celebratory gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, "#0a2020");
  grad.addColorStop(0.5, "#1a3530");
  grad.addColorStop(1, "#0a2020");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
  
  // Sparkle particles
  ctx.fillStyle = "rgba(255,255,255,0.5)";
  for (let i = 0; i < 20; i++) {
    const px = (frame * (i + 1) * 1.7 + i * 137) % W;
    const py = (frame * 0.5 + i * 43) % H;
    const size = 1 + Math.sin(frame * 0.1 + i) * 0.5;
    ctx.beginPath();
    ctx.arc(px, py, size, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Logos
  drawCDWLogo(32, 105, 1.0);
  drawCiscoLogo(W - 32, 105, 1.0);
  
  // Title
  ctx.fillStyle = BRAND.duoGreen;
  ctx.font = "bold 16px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("CUSTOMER PROTECTED!", W/2, 60);
  
  // Checkmarks
  ctx.fillStyle = "#fff";
  ctx.font = "9px monospace";
  ctx.fillText("✓ USERS VERIFIED", W/2, 85);
  ctx.fillText("✓ DEVICES VALIDATED", W/2, 98);
  ctx.fillText("✓ ACCESS CONTROLLED", W/2, 111);
  ctx.fillText("✓ DATA SECURED", W/2, 124);
  
  // Tagline
  ctx.fillStyle = getShieldInfo().color;
  ctx.font = "bold 12px sans-serif";
  ctx.fillText("IDENTITY: THE NEW PERIMETER", W/2, 140);
  
  // Clearance code box
  ctx.strokeStyle = BRAND.duoGreen;
  ctx.lineWidth = 2;
  ctx.strokeRect(45, 152, W - 90, 52);
  
  ctx.fillStyle = "#aaa";
  ctx.font = "8px monospace";
  ctx.fillText("CLEARANCE CODE:", W/2, 164);
  
  ctx.fillStyle = "#fff";
  ctx.font = "7px monospace";
  if (frame % 70 < 55) {
    ctx.fillText("WE DON'T PLAY GAMES WITH", W/2, 176);
    ctx.fillText("CUSTOMER IDENTITIES,", W/2, 186);
    ctx.fillText("NETWORKS, OR DATA.", W/2, 196);
  }
  
  // Restart prompt
  if (frame % 60 < 40) {
    ctx.fillStyle = "#888";
    ctx.font = "8px monospace";
    ctx.fillText("Press A to Play Again", W/2, 216);
  }
}

function drawTitle() {
  // Background
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0a1020');
  grad.addColorStop(0.5, '#1a2a4a');
  grad.addColorStop(1, '#0a1020');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
  
  // Animated grid
  ctx.strokeStyle = 'rgba(0, 200, 255, 0.15)';
  ctx.lineWidth = 1;
  for (let i = 0; i < 15; i++) {
    const off = (frame * 0.5) % 30;
    ctx.beginPath();
    ctx.moveTo(i * 30 - off, 0);
    ctx.lineTo(i * 30 - off + 20, H);
    ctx.stroke();
  }
  
  // Logos
  drawCDWLogo(W/2 - 50, 45, 1.2);
  
  // "+" symbol
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 20px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('+', W/2, 50);
  
  drawCiscoLogo(W/2 + 50, 45, 1.2);
  
  // Title
  ctx.fillStyle = '#000';
  ctx.font = 'bold 16px sans-serif';
  ctx.fillText('SUPER IDENTITY', W/2 + 1, 86);
  ctx.fillText('PARTNERS', W/2 + 1, 104);
  
  ctx.fillStyle = '#fff';
  ctx.fillText('SUPER IDENTITY', W/2, 85);
  ctx.fillText('PARTNERS', W/2, 103);
  
  // Tagline
  ctx.fillStyle = getShieldInfo().color;
  ctx.font = '9px sans-serif';
  ctx.fillText('Their Network. Our Mission. Zero Trust.', W/2, 120);
  
  // Instructions
  ctx.fillStyle = '#aaa';
  ctx.font = '8px sans-serif';
  ctx.fillText('Collect MFA Tokens to Protect Customer Networks', W/2, 145);
  ctx.fillText('← → Move | A = Jump', W/2, 158);  // QA FIX: removed B reference
  ctx.fillText('Stomp threats to neutralize them!', W/2, 171);
  
  // Blink
  if (Math.floor(frame / 25) % 2 === 0) {
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 11px sans-serif';
    ctx.fillText('Press A to Start', W/2, 195);
  }
  
  // Footer
  ctx.fillStyle = '#666';
  ctx.font = '7px sans-serif';
  ctx.fillText('CDW × CISCO Identity Security Summit 2026', W/2, H - 8);
}

// ============================================================
// WIN SCREEN
// ============================================================
function drawWin() {
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0a2010');
  grad.addColorStop(1, '#1a4020');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
  
  // Logos
  drawCDWLogo(W/2 - 40, 35, 0.9);
  drawCiscoLogo(W/2 + 40, 35, 0.9);
  
  ctx.fillStyle = BRAND.duoGreen;
  ctx.font = 'bold 18px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('NETWORK SECURED!', W/2, 75);
  
  ctx.fillStyle = '#fff';
  ctx.font = '10px sans-serif';
  ctx.fillText('✓ Users Verified', W/2, 100);
  ctx.fillText('✓ Devices Trusted', W/2, 115);
  ctx.fillText('✓ Access Controlled', W/2, 130);
  
  ctx.fillStyle = BRAND.duoGreen;
  ctx.fillText('MFA Deployed: ' + collectedTokens + '/' + tokens.length, W/2, 155);
  
  ctx.fillStyle = '#aaa';
  ctx.font = '9px sans-serif';
  ctx.fillText('Customer Protected with CDW + Cisco', W/2, 175);
  
  if (frame % 50 < 25) {
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 10px sans-serif';
    ctx.fillText('Press A to Start', W/2, 200);
  }
}

// ============================================================
// LOSE SCREEN
// ============================================================
function drawLose() {
  ctx.fillStyle = 'rgba(20, 0, 0, 0.95)';
  ctx.fillRect(0, 0, W, H);
  
  ctx.fillStyle = '#ff4444';
  ctx.font = 'bold 18px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('BREACH DETECTED', W/2, H/2 - 30);
  
  ctx.fillStyle = '#ff8888';
  ctx.font = '11px sans-serif';
  ctx.fillText('Identity Compromised!', W/2, H/2);
  
  ctx.fillStyle = '#aaa';
  ctx.font = '9px sans-serif';
  ctx.fillText('Deploy more MFA to protect customers', W/2, H/2 + 25);
  
  if (frame % 50 < 25) {
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 10px sans-serif';
    ctx.fillText('Press A to Retry', W/2, H/2 + 55);
  }
}

// ============================================================
// MAIN LOOP - 60fps locked (robust timing)
// ============================================================
const TARGET_FPS = 60;
const FRAME_TIME = 1000 / TARGET_FPS;
let lastTime = 0;
let accumulator = 0;
let lastUpdateTime = 0;

function update() {
  frame++;
  updateInput();
  
  if (screenShake > 0) screenShake--;
  if (hitstop > 0) { hitstop--; return; }
  
  // STATE: TITLE
  if (state === "title") {
    if (pressed.start || pressed.a) {
      state = "intro";
      introScreen = 0;
      currentLevel = 1;
      lives = 5;
      playMusic("title"); // Keep title music during intro
    }
  }
  // STATE: INTRO (3 screens)
  else if (state === "intro") {
    if (pressed.start || pressed.a) {
      introScreen++;
      if (introScreen >= 3) {
        state = "levelIntro";
        levelTransitionTimer = 0;
        playMusic("level" + currentLevel);
      }
    }
  }
  // STATE: LEVEL INTRO
  else if (state === "levelIntro") {
    // Button required - no auto-advance
    if (pressed.start || pressed.a) {
      state = "enemyPreview";
    }
  }
  // STATE: ENEMY PREVIEW
  else if (state === "enemyPreview") {
    if (pressed.start || pressed.a) {
      state = "play";
      initLevel();
    }
  }
  // STATE: PLAY
  else if (state === "play") {
    if (pressed.start) {
      state = "pause";
      return;
    }
    updatePlayer();
    updateEnemies();
    updatePowerups();
    updateParticles();
    updateCamera();
  }
  // STATE: PAUSE
  else if (state === "pause") {
    if (pressed.start) state = "play";
  }
  // STATE: LEVEL COMPLETE
  else if (state === "levelComplete") {
    // Button required - no auto-advance
    if (pressed.start || pressed.a) {
      if (currentLevel >= maxLevels) {
        state = "victory";
        playMusic("victory");
      } else {
        currentLevel++;
        playMusic("level" + currentLevel);
        state = "levelIntro";
        levelTransitionTimer = 0;
      }
    }
  }
  // STATE: VICTORY
  else if (state === "victory") {
    if (pressed.start || pressed.a) {
      state = "title";
      playMusic("title");
    }
  }
  // STATE: LOSE
  else if (state === "lose") {
    if (pressed.start || pressed.a) {
      state = "title";
      lives = 5;
      playMusic("title");
    }
  }
}

function draw() {
  ctx.save();
  
  if (screenShake > 0) {
    ctx.translate(
      (Math.random() - 0.5) * screenShake * 2,
      (Math.random() - 0.5) * screenShake * 2
    );
  }
  
  if (state === "title") {
    drawTitle();
  } else if (state === "intro") {
    drawIntro();
  } else if (state === "levelIntro") {
    drawLevelIntro();
  } else if (state === "enemyPreview") {
    drawEnemyPreview();
  } else if (state === "play" || state === "pause") {
    drawBackground();
    drawLevel();
    drawForeground();
    drawHUD();
    
    // Update particles in play state
    
    if (state === "pause") {
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = "#fff";
      ctx.font = "bold 18px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("PAUSED", W/2, H/2);
      ctx.font = "10px sans-serif";
      ctx.fillText("Press A to Start", W/2, H/2 + 20);
      ctx.textAlign = "left";
    }
  } else if (state === "levelComplete") {
    drawLevelComplete();
  } else if (state === "victory") {
    drawVictory();
  } else if (state === "lose") {
    drawLose();
  }
  
  ctx.restore();
}
function gameLoop(timestamp) {
  const now = performance.now();
  
  // Initialize on first frame
  if (!lastTime) {
    lastTime = now;
    lastUpdateTime = now;
  }
  
  // Calculate time since last update
  const timeSinceUpdate = now - lastUpdateTime;
  
  // Only update if enough time has passed (60fps = 16.67ms per frame)
  if (timeSinceUpdate >= FRAME_TIME) {
    // How many frames should have passed (cap at 3 to prevent spiral)
    let framesToRun = Math.floor(timeSinceUpdate / FRAME_TIME);
    if (framesToRun > 3) framesToRun = 3;
    
    // Run updates
    for (let i = 0; i < framesToRun; i++) {
      update();
    }
    
    // Advance lastUpdateTime by exact frame times (not actual elapsed)
    lastUpdateTime += framesToRun * FRAME_TIME;
    
    // Prevent drift by resetting if we fall too far behind
    if (now - lastUpdateTime > FRAME_TIME * 2) {
      lastUpdateTime = now;
    }
  }
  
  draw();
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
console.log('SIP v0.67 - Full CDW/Cisco Branding + Themed Enemies');

// DEBUG FUNCTIONS (web only - not in APK)
function dbgTitle() { state = "title"; initAudio(); playMusic("title"); }
function toggleGodMode() {
  godMode = !godMode;
  const btn = document.getElementById("godBtn");
  if (godMode) {
    btn.style.background = "#080";
    btn.style.borderColor = "#0f0";
    btn.style.color = "#0f0";
    btn.textContent = "GOD ✓";
    player.invincible = 999;
  } else {
    btn.style.background = "#440";
    btn.style.borderColor = "#880";
    btn.style.color = "#aa0";
    btn.textContent = "GOD";
    player.invincible = 0;
  }
}

function dbgLevel(n) { currentLevel = n; state = "levelIntro"; levelTransitionTimer = 0; initAudio(); playMusic("level" + n); }
function dbgComplete() { state = "levelComplete"; levelTransitionTimer = 0; initAudio(); playMusic("win"); }
function dbgVictory() { state = "victory"; initAudio(); playMusic("victory"); }
function dbgLose() { state = "lose"; initAudio(); playMusic("lose"); }
</script>
</body>
</html>
